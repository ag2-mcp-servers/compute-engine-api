# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T01:32:02+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Path, Query
from pydantic import conint

from models import (
    AcceleratorType,
    AcceleratorTypeAggregatedList,
    AcceleratorTypeList,
    AccessConfig,
    Address,
    AddressAggregatedList,
    AddressList,
    Alt,
    AttachedDisk,
    Autoscaler,
    AutoscalerAggregatedList,
    AutoscalerList,
    BackendBucket,
    BackendBucketList,
    BackendService,
    BackendServiceAggregatedList,
    BackendServiceGroupHealth,
    BackendServiceList,
    BulkInsertInstanceResource,
    CacheInvalidationRule,
    Commitment,
    CommitmentAggregatedList,
    CommitmentList,
    DeprecationStatus,
    Direction3,
    Disk,
    DiskAggregatedList,
    DiskList,
    DiskMoveRequest,
    DisksAddResourcePoliciesRequest,
    DisksRemoveResourcePoliciesRequest,
    DisksResizeRequest,
    DiskType,
    DiskTypeAggregatedList,
    DiskTypeList,
    DisplayDevice,
    ExchangedPeeringRoutesList,
    ExternalVpnGateway,
    ExternalVpnGatewayList,
    FieldXgafv,
    Firewall,
    FirewallList,
    FirewallPoliciesListAssociationsResponse,
    FirewallPolicy,
    FirewallPolicyAssociation,
    FirewallPolicyList,
    FirewallPolicyRule,
    ForwardingRule,
    ForwardingRuleAggregatedList,
    ForwardingRuleList,
    GlobalNetworkEndpointGroupsAttachEndpointsRequest,
    GlobalNetworkEndpointGroupsDetachEndpointsRequest,
    GlobalOrganizationSetPolicyRequest,
    GlobalSetLabelsRequest,
    GlobalSetPolicyRequest,
    GuestAttributes,
    HealthCheck,
    HealthCheckList,
    HealthChecksAggregatedList,
    HealthCheckService,
    HealthCheckServicesList,
    HttpHealthCheck,
    HttpHealthCheckList,
    HttpsHealthCheck,
    HttpsHealthCheckList,
    Image,
    ImageFamilyView,
    ImageList,
    Instance,
    InstanceAggregatedList,
    InstanceGroup,
    InstanceGroupAggregatedList,
    InstanceGroupList,
    InstanceGroupManager,
    InstanceGroupManagerAggregatedList,
    InstanceGroupManagerList,
    InstanceGroupManagersAbandonInstancesRequest,
    InstanceGroupManagersApplyUpdatesRequest,
    InstanceGroupManagersCreateInstancesRequest,
    InstanceGroupManagersDeleteInstancesRequest,
    InstanceGroupManagersDeletePerInstanceConfigsReq,
    InstanceGroupManagersListErrorsResponse,
    InstanceGroupManagersListManagedInstancesResponse,
    InstanceGroupManagersListPerInstanceConfigsResp,
    InstanceGroupManagersPatchPerInstanceConfigsReq,
    InstanceGroupManagersRecreateInstancesRequest,
    InstanceGroupManagersSetInstanceTemplateRequest,
    InstanceGroupManagersSetTargetPoolsRequest,
    InstanceGroupManagersUpdatePerInstanceConfigsReq,
    InstanceGroupsAddInstancesRequest,
    InstanceGroupsListInstances,
    InstanceGroupsListInstancesRequest,
    InstanceGroupsRemoveInstancesRequest,
    InstanceGroupsSetNamedPortsRequest,
    InstanceList,
    InstanceListReferrers,
    InstanceMoveRequest,
    InstanceReference,
    InstancesAddResourcePoliciesRequest,
    InstancesGetEffectiveFirewallsResponse,
    InstancesRemoveResourcePoliciesRequest,
    InstancesSetLabelsRequest,
    InstancesSetMachineResourcesRequest,
    InstancesSetMachineTypeRequest,
    InstancesSetMinCpuPlatformRequest,
    InstancesSetNameRequest,
    InstancesSetServiceAccountRequest,
    InstancesStartWithEncryptionKeyRequest,
    InstanceTemplate,
    InstanceTemplateAggregatedList,
    InstanceTemplateList,
    Interconnect,
    InterconnectAttachment,
    InterconnectAttachmentAggregatedList,
    InterconnectAttachmentList,
    InterconnectList,
    InterconnectLocation,
    InterconnectLocationList,
    InterconnectsGetDiagnosticsResponse,
    License,
    LicenseCode,
    LicensesListResponse,
    MachineImage,
    MachineImageList,
    MachineType,
    MachineTypeAggregatedList,
    MachineTypeList,
    MetadataModel,
    MinimalAction3,
    MostDisruptiveAllowedAction3,
    Network,
    NetworkAttachment,
    NetworkAttachmentAggregatedList,
    NetworkAttachmentList,
    NetworkEdgeSecurityService,
    NetworkEdgeSecurityServiceAggregatedList,
    NetworkEndpointGroup,
    NetworkEndpointGroupAggregatedList,
    NetworkEndpointGroupList,
    NetworkEndpointGroupsAttachEndpointsRequest,
    NetworkEndpointGroupsDetachEndpointsRequest,
    NetworkEndpointGroupsListEndpointsRequest,
    NetworkEndpointGroupsListNetworkEndpoints,
    NetworkInterface,
    NetworkList,
    NetworksAddPeeringRequest,
    NetworksGetEffectiveFirewallsResponse,
    NetworksRemovePeeringRequest,
    NetworksUpdatePeeringRequest,
    NodeGroup,
    NodeGroupAggregatedList,
    NodeGroupList,
    NodeGroupsAddNodesRequest,
    NodeGroupsDeleteNodesRequest,
    NodeGroupsListNodes,
    NodeGroupsSetNodeTemplateRequest,
    NodeGroupsSimulateMaintenanceEventRequest,
    NodeTemplate,
    NodeTemplateAggregatedList,
    NodeTemplateList,
    NodeType,
    NodeTypeAggregatedList,
    NodeTypeList,
    NotificationEndpoint,
    NotificationEndpointList,
    Operation,
    OperationAggregatedList,
    OperationList,
    PacketMirroring,
    PacketMirroringAggregatedList,
    PacketMirroringList,
    Paths,
    Policy,
    Project,
    ProjectsDisableXpnResourceRequest,
    ProjectsEnableXpnResourceRequest,
    ProjectsGetXpnResources,
    ProjectsListXpnHostsRequest,
    ProjectsSetDefaultNetworkTierRequest,
    PublicAdvertisedPrefix,
    PublicAdvertisedPrefixList,
    PublicDelegatedPrefix,
    PublicDelegatedPrefixAggregatedList,
    PublicDelegatedPrefixList,
    Region,
    RegionAutoscalerList,
    RegionDisksAddResourcePoliciesRequest,
    RegionDisksRemoveResourcePoliciesRequest,
    RegionDisksResizeRequest,
    RegionDiskTypeList,
    RegionInstanceGroupList,
    RegionInstanceGroupManagerDeleteInstanceConfigReq,
    RegionInstanceGroupManagerList,
    RegionInstanceGroupManagerPatchInstanceConfigReq,
    RegionInstanceGroupManagersAbandonInstancesRequest,
    RegionInstanceGroupManagersApplyUpdatesRequest,
    RegionInstanceGroupManagersCreateInstancesRequest,
    RegionInstanceGroupManagersDeleteInstancesRequest,
    RegionInstanceGroupManagersListErrorsResponse,
    RegionInstanceGroupManagersListInstanceConfigsResp,
    RegionInstanceGroupManagersListInstancesResponse,
    RegionInstanceGroupManagersRecreateRequest,
    RegionInstanceGroupManagersSetTargetPoolsRequest,
    RegionInstanceGroupManagersSetTemplateRequest,
    RegionInstanceGroupManagerUpdateInstanceConfigReq,
    RegionInstanceGroupsListInstances,
    RegionInstanceGroupsListInstancesRequest,
    RegionInstanceGroupsSetNamedPortsRequest,
    RegionList,
    RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse,
    RegionSetLabelsRequest,
    RegionSetPolicyRequest,
    RegionTargetHttpsProxiesSetSslCertificatesRequest,
    RegionUrlMapsValidateRequest,
    Reservation,
    ReservationAggregatedList,
    ReservationList,
    ReservationsResizeRequest,
    ResourceGroupReference,
    ResourcePolicy,
    ResourcePolicyAggregatedList,
    ResourcePolicyList,
    Route,
    RouteList,
    Router,
    RouterAggregatedList,
    RouterList,
    RoutersPreviewResponse,
    RouterStatusResponse,
    Scheduling,
    Screenshot,
    SecurityPoliciesAggregatedList,
    SecurityPoliciesListPreconfiguredExpressionSetsResponse,
    SecurityPolicy,
    SecurityPolicyList,
    SecurityPolicyReference,
    SecurityPolicyRule,
    SerialPortOutput,
    ServiceAttachment,
    ServiceAttachmentAggregatedList,
    ServiceAttachmentList,
    ShieldedInstanceConfig,
    ShieldedInstanceIdentity,
    ShieldedInstanceIntegrityPolicy,
    SignedUrlKey,
    Snapshot,
    SnapshotList,
    SslCertificate,
    SslCertificateAggregatedList,
    SslCertificateList,
    SslPoliciesAggregatedList,
    SslPoliciesList,
    SslPoliciesListAvailableFeaturesResponse,
    SslPolicy,
    SslPolicyReference,
    Subnetwork,
    SubnetworkAggregatedList,
    SubnetworkList,
    SubnetworksExpandIpCidrRangeRequest,
    SubnetworksSetPrivateIpGoogleAccessRequest,
    Tags,
    TargetGrpcProxy,
    TargetGrpcProxyList,
    TargetHttpProxy,
    TargetHttpProxyAggregatedList,
    TargetHttpProxyList,
    TargetHttpsProxiesSetCertificateMapRequest,
    TargetHttpsProxiesSetQuicOverrideRequest,
    TargetHttpsProxiesSetSslCertificatesRequest,
    TargetHttpsProxy,
    TargetHttpsProxyAggregatedList,
    TargetHttpsProxyList,
    TargetInstance,
    TargetInstanceAggregatedList,
    TargetInstanceList,
    TargetPool,
    TargetPoolAggregatedList,
    TargetPoolInstanceHealth,
    TargetPoolList,
    TargetPoolsAddHealthCheckRequest,
    TargetPoolsAddInstanceRequest,
    TargetPoolsRemoveHealthCheckRequest,
    TargetPoolsRemoveInstanceRequest,
    TargetReference,
    TargetSslProxiesSetBackendServiceRequest,
    TargetSslProxiesSetCertificateMapRequest,
    TargetSslProxiesSetProxyHeaderRequest,
    TargetSslProxiesSetSslCertificatesRequest,
    TargetSslProxy,
    TargetSslProxyList,
    TargetTcpProxiesSetBackendServiceRequest,
    TargetTcpProxiesSetProxyHeaderRequest,
    TargetTcpProxy,
    TargetTcpProxyAggregatedList,
    TargetTcpProxyList,
    TargetVpnGateway,
    TargetVpnGatewayAggregatedList,
    TargetVpnGatewayList,
    TestPermissionsRequest,
    TestPermissionsResponse,
    UrlMap,
    UrlMapList,
    UrlMapReference,
    UrlMapsAggregatedList,
    UrlMapsValidateRequest,
    UrlMapsValidateResponse,
    UsableSubnetworksAggregatedList,
    UsageExportLocation,
    VmEndpointNatMappingsList,
    VpnGateway,
    VpnGatewayAggregatedList,
    VpnGatewayList,
    VpnGatewaysGetStatusResponse,
    VpnTunnel,
    VpnTunnelAggregatedList,
    VpnTunnelList,
    XpnHostList,
    Zone,
    ZoneList,
    ZoneSetLabelsRequest,
    ZoneSetPolicyRequest,
)

app = MCPProxy(
    contact={'name': 'Google', 'url': 'https://google.com', 'x-twitter': 'youtube'},
    description='Creates and runs virtual machines on Google Cloud Platform. ',
    license={
        'name': 'Creative Commons Attribution 3.0',
        'url': 'http://creativecommons.org/licenses/by/3.0/',
    },
    termsOfService='https://developers.google.com/terms/',
    title='Compute Engine API',
    version='v1',
    servers=[{'url': 'https://compute.googleapis.com/compute/v1'}],
)


@app.get(
    '/locations/global/firewallPolicies',
    description=""" Lists all the policies that have been configured for the specified folder or organization. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_list(
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    parent_id: Optional[str] = Query(None, alias='parentId'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations/global/firewallPolicies',
    description=""" Creates a new policy in the specified project using the data included in the request. """,
    tags=[
        'network_firewall_policy_management',
        'firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_insert(
    parent_id: Optional[str] = Query(None, alias='parentId'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations/global/firewallPolicies/listAssociations',
    description=""" Lists associations of a specified target, i.e., organization or folder. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_list_associations(
    target_resource: Optional[str] = Query(None, alias='targetResource'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/locations/global/firewallPolicies/{firewallPolicy}',
    description=""" Deletes the specified policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_delete(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations/global/firewallPolicies/{firewallPolicy}',
    description=""" Returns the specified firewall policy. """,
    tags=[
        'network_firewall_policy_management',
        'firewall_policy_management',
        'firewall_rule_management',
        'firewall_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_get(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/locations/global/firewallPolicies/{firewallPolicy}',
    description=""" Patches the specified policy with the data included in the request. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_patch(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations/global/firewallPolicies/{firewallPolicy}/addAssociation',
    description=""" Inserts an association for the specified firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_add_association(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    replace_existing_association: Optional[bool] = Query(
        None, alias='replaceExistingAssociation'
    ),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicyAssociation = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations/global/firewallPolicies/{firewallPolicy}/addRule',
    description=""" Inserts a rule into a firewall policy. """,
    tags=[
        'firewall_policy_management',
        'firewall_rule_management',
        'firewall_management',
        'network_firewall_policy_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_add_rule(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicyRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations/global/firewallPolicies/{firewallPolicy}/cloneRules',
    description=""" Copies rules to the specified firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_clone_rules(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    source_firewall_policy: Optional[str] = Query(None, alias='sourceFirewallPolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations/global/firewallPolicies/{firewallPolicy}/getAssociation',
    description=""" Gets an association with the specified name. """,
    tags=[
        'network_firewall_policy_management',
        'firewall_policy_management',
        'firewall_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_get_association(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    name: Optional[str] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations/global/firewallPolicies/{firewallPolicy}/getRule',
    description=""" Gets a rule of the specified priority. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_policy_iam_management',
        'firewall_rule_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_get_rule(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    priority: Optional[int] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations/global/firewallPolicies/{firewallPolicy}/move',
    description=""" Moves the specified firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_move(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    parent_id: Optional[str] = Query(None, alias='parentId'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations/global/firewallPolicies/{firewallPolicy}/patchRule',
    description=""" Patches a rule of the specified priority. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_rule_management',
        'firewall_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_patch_rule(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    priority: Optional[int] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicyRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations/global/firewallPolicies/{firewallPolicy}/removeAssociation',
    description=""" Removes an association for the specified firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_remove_association(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    name: Optional[str] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations/global/firewallPolicies/{firewallPolicy}/removeRule',
    description=""" Deletes a rule of the specified priority. """,
    tags=[
        'network_firewall_policy_management',
        'firewall_policy_management',
        'firewall_rule_management',
        'firewall_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_remove_rule(
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    priority: Optional[int] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations/global/firewallPolicies/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_get_iam_policy(
    resource: str,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations/global/firewallPolicies/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['global_operations_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_set_iam_policy(
    resource: str,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalOrganizationSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations/global/firewallPolicies/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['firewall_policy_iam_management', 'firewall_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewall_policies_test_iam_permissions(
    resource: str,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations/global/operations',
    description=""" Retrieves a list of Operation resources contained within the specified organization. """,
    tags=[
        'project_retrieval',
        'project_management_operations',
        'resource_aggregated_lists',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_organization_operations_list(
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    parent_id: Optional[str] = Query(None, alias='parentId'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/locations/global/operations/{operation}',
    description=""" Deletes the specified Operations resource. """,
    tags=['global_operations_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_organization_operations_delete(
    operation: str,
    parent_id: Optional[str] = Query(None, alias='parentId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations/global/operations/{operation}',
    description=""" Retrieves the specified Operations resource. Gets a list of operations by making a `list()` request. """,
    tags=['global_operations_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_organization_operations_get(
    operation: str,
    parent_id: Optional[str] = Query(None, alias='parentId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}',
    description=""" Returns the specified Project resource. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is especially recommended for unused quota information (the `quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need. For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_get(
    project: str,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/acceleratorTypes',
    description=""" Retrieves an aggregated list of accelerator types. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_accelerator_types_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/addresses',
    description=""" Retrieves an aggregated list of addresses. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_addresses_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/autoscalers',
    description=""" Retrieves an aggregated list of autoscalers. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_autoscalers_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/backendServices',
    description=""" Retrieves the list of all BackendService resources, regional and global, available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/commitments',
    description=""" Retrieves an aggregated list of commitments by region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_commitments_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/diskTypes',
    description=""" Retrieves an aggregated list of disk types. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disk_types_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/disks',
    description=""" Retrieves an aggregated list of persistent disks. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/forwardingRules',
    description=""" Retrieves an aggregated list of forwarding rules. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_forwarding_rules_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/healthChecks',
    description=""" Retrieves the list of all HealthCheck resources, regional and global, available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_health_checks_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/instanceGroupManagers',
    description=""" Retrieves the list of managed instance groups and groups them by zone. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/instanceGroups',
    description=""" Retrieves the list of instance groups and sorts them by zone. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_groups_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/instanceTemplates',
    description=""" Retrieves the list of all InstanceTemplates resources, regional and global, available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_templates_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/instances',
    description=""" Retrieves an aggregated list of all of the instances in your project across all regions and zones. The performance of this method degrades when a filter is specified on a project that has a very large number of instances. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/interconnectAttachments',
    description=""" Retrieves an aggregated list of interconnect attachments. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnect_attachments_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/machineTypes',
    description=""" Retrieves an aggregated list of machine types. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_machine_types_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/networkAttachments',
    description=""" Retrieves the list of all NetworkAttachment resources, regional and global, available to the specified project. """,
    tags=[
        'project_management_operations',
        'global_operations_management',
        'project_retrieval',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_attachments_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/networkEdgeSecurityServices',
    description=""" Retrieves the list of all NetworkEdgeSecurityService resources available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_edge_security_services_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/networkEndpointGroups',
    description=""" Retrieves the list of network endpoint groups and sorts them by zone. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_endpoint_groups_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/nodeGroups',
    description=""" Retrieves an aggregated list of node groups. Note: use nodeGroups.listNodes for more details about each group. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/nodeTemplates',
    description=""" Retrieves an aggregated list of node templates. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_templates_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/nodeTypes',
    description=""" Retrieves an aggregated list of node types. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_types_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/operations',
    description=""" Retrieves an aggregated list of all operations. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_operations_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/packetMirrorings',
    description=""" Retrieves an aggregated list of packetMirrorings. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_packet_mirrorings_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/publicDelegatedPrefixes',
    description=""" Lists all PublicDelegatedPrefix resources owned by the specific project across all scopes. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_delegated_prefixes_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/reservations',
    description=""" Retrieves an aggregated list of reservations. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_reservations_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/resourcePolicies',
    description=""" Retrieves an aggregated list of resource policies. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_resource_policies_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/routers',
    description=""" Retrieves an aggregated list of routers. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routers_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/securityPolicies',
    description=""" Retrieves the list of all SecurityPolicy resources, regional and global, available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/serviceAttachments',
    description=""" Retrieves the list of all ServiceAttachment resources, regional and global, available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_service_attachments_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/sslCertificates',
    description=""" Retrieves the list of all SslCertificate resources, regional and global, available to the specified project. """,
    tags=[
        'project_management_operations',
        'resource_aggregated_lists',
        'project_retrieval',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_certificates_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/sslPolicies',
    description=""" Retrieves the list of all SslPolicy resources, regional and global, available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_policies_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/subnetworks',
    description=""" Retrieves an aggregated list of subnetworks. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/subnetworks/listUsable',
    description=""" Retrieves an aggregated list of all usable subnetworks in the project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_list_usable(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/targetHttpProxies',
    description=""" Retrieves the list of all TargetHttpProxy resources, regional and global, available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_http_proxies_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/targetHttpsProxies',
    description=""" Retrieves the list of all TargetHttpsProxy resources, regional and global, available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/targetInstances',
    description=""" Retrieves an aggregated list of target instances. """,
    tags=['project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_instances_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/targetPools',
    description=""" Retrieves an aggregated list of target pools. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/targetTcpProxies',
    description=""" Retrieves the list of all TargetTcpProxy resources, regional and global, available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_tcp_proxies_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/targetVpnGateways',
    description=""" Retrieves an aggregated list of target VPN gateways. """,
    tags=['project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_vpn_gateways_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/urlMaps',
    description=""" Retrieves the list of all UrlMap resources, regional and global, available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_url_maps_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/vpnGateways',
    description=""" Retrieves an aggregated list of VPN gateways. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'global_operations_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_gateways_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/aggregated/vpnTunnels',
    description=""" Retrieves an aggregated list of VPN tunnels. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_tunnels_aggregated_list(
    project: str,
    filter: Optional[str] = None,
    include_all_scopes: Optional[bool] = Query(None, alias='includeAllScopes'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/disableXpnHost',
    description=""" Disable this project as a shared VPC host project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_disable_xpn_host(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/disableXpnResource',
    description=""" Disable a service resource (also known as service project) associated with this host project. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_disable_xpn_resource(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ProjectsDisableXpnResourceRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/enableXpnHost',
    description=""" Enable this project as a shared VPC host project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_enable_xpn_host(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/enableXpnResource',
    description=""" Enable service resource (a.k.a service project) for a host project, so that subnets in the host project can be used by instances in the service project. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_enable_xpn_resource(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ProjectsEnableXpnResourceRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/getXpnHost',
    description=""" Gets the shared VPC host project that this project links to. May be empty if no link exists. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_get_xpn_host(
    project: str,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/getXpnResources',
    description=""" Gets service resources (a.k.a service project) associated with this host project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_get_xpn_resources(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/addresses',
    description=""" Retrieves a list of global addresses. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_addresses_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/addresses',
    description=""" Creates an address resource in the specified project by using the data included in the request. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_addresses_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Address = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/addresses/{address}',
    description=""" Deletes the specified address resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_addresses_delete(
    project: str,
    address: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/addresses/{address}',
    description=""" Returns the specified address resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_addresses_get(
    project: str,
    address: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/addresses/{resource}/setLabels',
    description=""" Sets the labels on a GlobalAddress. To learn more about labels, read the Labeling Resources documentation. """,
    tags=['global_operations_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_addresses_set_labels(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/backendBuckets',
    description=""" Retrieves the list of BackendBucket resources available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_buckets_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendBuckets',
    description=""" Creates a BackendBucket resource in the specified project using the data included in the request. """,
    tags=['backend_bucket_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_buckets_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BackendBucket = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/backendBuckets/{backendBucket}',
    description=""" Deletes the specified BackendBucket resource. """,
    tags=['backend_bucket_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_buckets_delete(
    project: str,
    backend_bucket: str = Path(..., alias='backendBucket'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/backendBuckets/{backendBucket}',
    description=""" Returns the specified BackendBucket resource. """,
    tags=['backend_bucket_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_buckets_get(
    project: str,
    backend_bucket: str = Path(..., alias='backendBucket'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/backendBuckets/{backendBucket}',
    description=""" Updates the specified BackendBucket resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=['backend_bucket_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_buckets_patch(
    project: str,
    backend_bucket: str = Path(..., alias='backendBucket'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BackendBucket = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/global/backendBuckets/{backendBucket}',
    description=""" Updates the specified BackendBucket resource with the data included in the request. """,
    tags=['backend_bucket_management', 'backend_service_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_buckets_update(
    project: str,
    backend_bucket: str = Path(..., alias='backendBucket'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BackendBucket = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendBuckets/{backendBucket}/addSignedUrlKey',
    description=""" Adds a key for validating requests with signed URLs for this backend bucket. """,
    tags=['backend_bucket_management', 'signed_url_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_buckets_add_signed_url_key(
    project: str,
    backend_bucket: str = Path(..., alias='backendBucket'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SignedUrlKey = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendBuckets/{backendBucket}/deleteSignedUrlKey',
    description=""" Deletes a key for validating requests with signed URLs for this backend bucket. """,
    tags=['backend_bucket_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_buckets_delete_signed_url_key(
    project: str,
    backend_bucket: str = Path(..., alias='backendBucket'),
    key_name: str = Query(..., alias='keyName'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendBuckets/{backendBucket}/setEdgeSecurityPolicy',
    description=""" Sets the edge security policy for the specified backend bucket. """,
    tags=['backend_bucket_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_buckets_set_edge_security_policy(
    project: str,
    backend_bucket: str = Path(..., alias='backendBucket'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SecurityPolicyReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/backendServices',
    description=""" Retrieves the list of BackendService resources available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendServices',
    description=""" Creates a BackendService resource in the specified project using the data included in the request. For more information, see Backend services overview . """,
    tags=['backend_service_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BackendService = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/backendServices/{backendService}',
    description=""" Deletes the specified BackendService resource. """,
    tags=['backend_service_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_delete(
    project: str,
    backend_service: str = Path(..., alias='backendService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/backendServices/{backendService}',
    description=""" Returns the specified BackendService resource. """,
    tags=['backend_service_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_get(
    project: str,
    backend_service: str = Path(..., alias='backendService'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/backendServices/{backendService}',
    description=""" Patches the specified BackendService resource with the data included in the request. For more information, see Backend services overview. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=[
        'backend_service_management',
        'backend_security_policy_management',
        'backend_service_health_checks',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_patch(
    project: str,
    backend_service: str = Path(..., alias='backendService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BackendService = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/global/backendServices/{backendService}',
    description=""" Updates the specified BackendService resource with the data included in the request. For more information, see Backend services overview. """,
    tags=['backend_service_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_update(
    project: str,
    backend_service: str = Path(..., alias='backendService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BackendService = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendServices/{backendService}/addSignedUrlKey',
    description=""" Adds a key for validating requests with signed URLs for this backend service. """,
    tags=['backend_service_management', 'signed_url_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_add_signed_url_key(
    project: str,
    backend_service: str = Path(..., alias='backendService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SignedUrlKey = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendServices/{backendService}/deleteSignedUrlKey',
    description=""" Deletes a key for validating requests with signed URLs for this backend service. """,
    tags=['backend_service_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_delete_signed_url_key(
    project: str,
    backend_service: str = Path(..., alias='backendService'),
    key_name: str = Query(..., alias='keyName'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendServices/{backendService}/getHealth',
    description=""" Gets the most recent health check results for this BackendService. Example request body: { "group": "/zones/us-east1-b/instanceGroups/lb-backend-example" } """,
    tags=['backend_service_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_get_health(
    project: str,
    backend_service: str = Path(..., alias='backendService'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ResourceGroupReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendServices/{backendService}/setEdgeSecurityPolicy',
    description=""" Sets the edge security policy for the specified backend service. """,
    tags=[
        'backend_service_management',
        'backend_security_policy_management',
        'backend_iam_policy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_set_edge_security_policy(
    project: str,
    backend_service: str = Path(..., alias='backendService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SecurityPolicyReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendServices/{backendService}/setSecurityPolicy',
    description=""" Sets the Google Cloud Armor security policy for the specified backend service. For more information, see Google Cloud Armor Overview """,
    tags=['backend_service_management', 'backend_security_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_set_security_policy(
    project: str,
    backend_service: str = Path(..., alias='backendService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SecurityPolicyReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/backendServices/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_get_iam_policy(
    project: str,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/backendServices/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_backend_services_set_iam_policy(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/externalVpnGateways',
    description=""" Retrieves the list of ExternalVpnGateway available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_external_vpn_gateways_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/externalVpnGateways',
    description=""" Creates a ExternalVpnGateway in the specified project using the data included in the request. """,
    tags=['external_vpn_gateway_management', 'vpn_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_external_vpn_gateways_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ExternalVpnGateway = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/externalVpnGateways/{externalVpnGateway}',
    description=""" Deletes the specified externalVpnGateway. """,
    tags=['external_vpn_gateway_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_external_vpn_gateways_delete(
    project: str,
    external_vpn_gateway: str = Path(..., alias='externalVpnGateway'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/externalVpnGateways/{externalVpnGateway}',
    description=""" Returns the specified externalVpnGateway. Get a list of available externalVpnGateways by making a list() request. """,
    tags=['external_vpn_gateway_management', 'vpn_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_external_vpn_gateways_get(
    project: str,
    external_vpn_gateway: str = Path(..., alias='externalVpnGateway'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/externalVpnGateways/{resource}/setLabels',
    description=""" Sets the labels on an ExternalVpnGateway. To learn more about labels, read the Labeling Resources documentation. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_external_vpn_gateways_set_labels(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/externalVpnGateways/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_external_vpn_gateways_test_iam_permissions(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/firewallPolicies',
    description=""" Lists all the policies that have been configured for the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/firewallPolicies',
    description=""" Creates a new policy in the specified project using the data included in the request. """,
    tags=[
        'firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
        'network_firewall_policy_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}',
    description=""" Deletes the specified policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_delete(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}',
    description=""" Returns the specified network firewall policy. """,
    tags=['network_firewall_policy_management', 'firewall_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_get(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}',
    description=""" Patches the specified policy with the data included in the request. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_patch(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}/addAssociation',
    description=""" Inserts an association for the specified firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_policy_iam_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_add_association(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    replace_existing_association: Optional[bool] = Query(
        None, alias='replaceExistingAssociation'
    ),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicyAssociation = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}/addRule',
    description=""" Inserts a rule into a firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_rule_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_add_rule(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    max_priority: Optional[int] = Query(None, alias='maxPriority'),
    min_priority: Optional[int] = Query(None, alias='minPriority'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicyRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}/cloneRules',
    description=""" Copies rules to the specified firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_clone_rules(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    source_firewall_policy: Optional[str] = Query(None, alias='sourceFirewallPolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}/getAssociation',
    description=""" Gets an association with the specified name. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_get_association(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    name: Optional[str] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule',
    description=""" Gets a rule of the specified priority. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_policy_iam_management',
        'firewall_rule_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_get_rule(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    priority: Optional[int] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}/patchRule',
    description=""" Patches a rule of the specified priority. """,
    tags=[
        'firewall_policy_management',
        'firewall_rule_management',
        'network_firewall_policy_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_patch_rule(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    priority: Optional[int] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicyRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}/removeAssociation',
    description=""" Removes an association for the specified firewall policy. """,
    tags=[
        'network_firewall_policy_management',
        'firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_remove_association(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    name: Optional[str] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/firewallPolicies/{firewallPolicy}/removeRule',
    description=""" Deletes a rule of the specified priority. """,
    tags=[
        'firewall_policy_management',
        'firewall_policy_iam_management',
        'firewall_rule_management',
        'firewall_management',
        'network_firewall_policy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_remove_rule(
    project: str,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    priority: Optional[int] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/firewallPolicies/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_get_iam_policy(
    project: str,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/firewallPolicies/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['global_operations_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_set_iam_policy(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/firewallPolicies/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['project_management_operations', 'firewall_policy_iam_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_firewall_policies_test_iam_permissions(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/firewalls',
    description=""" Retrieves the list of firewall rules available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewalls_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/firewalls',
    description=""" Creates a firewall rule in the specified project using the data included in the request. """,
    tags=[
        'firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewalls_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Firewall = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/firewalls/{firewall}',
    description=""" Deletes the specified firewall. """,
    tags=[
        'firewall_policy_management',
        'firewall_management',
        'network_firewall_policy_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewalls_delete(
    project: str,
    firewall: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/firewalls/{firewall}',
    description=""" Returns the specified firewall. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewalls_get(
    project: str,
    firewall: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/firewalls/{firewall}',
    description=""" Updates the specified firewall rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=[
        'firewall_management',
        'firewall_policy_management',
        'network_firewall_policy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewalls_patch(
    project: str,
    firewall: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Firewall = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/global/firewalls/{firewall}',
    description=""" Updates the specified firewall rule with the data included in the request. Note that all fields will be updated if using PUT, even fields that are not specified. To update individual fields, please use PATCH instead. """,
    tags=[
        'firewall_management',
        'firewall_policy_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_firewalls_update(
    project: str,
    firewall: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Firewall = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/forwardingRules',
    description=""" Retrieves a list of GlobalForwardingRule resources available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_forwarding_rules_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/forwardingRules',
    description=""" Creates a GlobalForwardingRule resource in the specified project using the data included in the request. """,
    tags=[
        'global_forwarding_rules_management',
        'global_operations_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_forwarding_rules_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ForwardingRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/forwardingRules/{forwardingRule}',
    description=""" Deletes the specified GlobalForwardingRule resource. """,
    tags=[
        'global_forwarding_rules_management',
        'network_firewall_policy_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_forwarding_rules_delete(
    project: str,
    forwarding_rule: str = Path(..., alias='forwardingRule'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/forwardingRules/{forwardingRule}',
    description=""" Returns the specified GlobalForwardingRule resource. Gets a list of available forwarding rules by making a list() request. """,
    tags=['global_forwarding_rules_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_forwarding_rules_get(
    project: str,
    forwarding_rule: str = Path(..., alias='forwardingRule'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/forwardingRules/{forwardingRule}',
    description=""" Updates the specified forwarding rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. Currently, you can only patch the network_tier field. """,
    tags=['global_forwarding_rules_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_forwarding_rules_patch(
    project: str,
    forwarding_rule: str = Path(..., alias='forwardingRule'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ForwardingRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/forwardingRules/{forwardingRule}/setTarget',
    description=""" Changes target URL for the GlobalForwardingRule resource. The new target should be of the same type as the old target. """,
    tags=[
        'global_forwarding_rules_management',
        'firewall_policy_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_forwarding_rules_set_target(
    project: str,
    forwarding_rule: str = Path(..., alias='forwardingRule'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/forwardingRules/{resource}/setLabels',
    description=""" Sets the labels on the specified resource. To learn more about labels, read the Labeling resources documentation. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_forwarding_rules_set_labels(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/healthChecks',
    description=""" Retrieves the list of HealthCheck resources available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_health_checks_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/healthChecks',
    description=""" Creates a HealthCheck resource in the specified project using the data included in the request. """,
    tags=['compute_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_health_checks_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/healthChecks/{healthCheck}',
    description=""" Deletes the specified HealthCheck resource. """,
    tags=['compute_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_health_checks_delete(
    project: str,
    health_check: str = Path(..., alias='healthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/healthChecks/{healthCheck}',
    description=""" Returns the specified HealthCheck resource. """,
    tags=['compute_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_health_checks_get(
    project: str,
    health_check: str = Path(..., alias='healthCheck'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/healthChecks/{healthCheck}',
    description=""" Updates a HealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=['compute_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_health_checks_patch(
    project: str,
    health_check: str = Path(..., alias='healthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/global/healthChecks/{healthCheck}',
    description=""" Updates a HealthCheck resource in the specified project using the data included in the request. """,
    tags=[
        'compute_health_checks_management',
        'health_checks_management',
        'backend_service_health_checks',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_health_checks_update(
    project: str,
    health_check: str = Path(..., alias='healthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/httpHealthChecks',
    description=""" Retrieves the list of HttpHealthCheck resources available to the specified project. """,
    tags=['project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_http_health_checks_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/httpHealthChecks',
    description=""" Creates a HttpHealthCheck resource in the specified project using the data included in the request. """,
    tags=[
        'http_health_checks_management',
        'health_checks_management',
        'compute_health_checks_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_http_health_checks_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HttpHealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/httpHealthChecks/{httpHealthCheck}',
    description=""" Deletes the specified HttpHealthCheck resource. """,
    tags=['http_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_http_health_checks_delete(
    project: str,
    http_health_check: str = Path(..., alias='httpHealthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/httpHealthChecks/{httpHealthCheck}',
    description=""" Returns the specified HttpHealthCheck resource. """,
    tags=['http_health_checks_management', 'compute_health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_http_health_checks_get(
    project: str,
    http_health_check: str = Path(..., alias='httpHealthCheck'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/httpHealthChecks/{httpHealthCheck}',
    description=""" Updates a HttpHealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=['http_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_http_health_checks_patch(
    project: str,
    http_health_check: str = Path(..., alias='httpHealthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HttpHealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/global/httpHealthChecks/{httpHealthCheck}',
    description=""" Updates a HttpHealthCheck resource in the specified project using the data included in the request. """,
    tags=[
        'http_health_checks_management',
        'health_checks_management',
        'compute_health_checks_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_http_health_checks_update(
    project: str,
    http_health_check: str = Path(..., alias='httpHealthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HttpHealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/httpsHealthChecks',
    description=""" Retrieves the list of HttpsHealthCheck resources available to the specified project. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_https_health_checks_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/httpsHealthChecks',
    description=""" Creates a HttpsHealthCheck resource in the specified project using the data included in the request. """,
    tags=[
        'https_health_checks_management',
        'health_checks_management',
        'compute_health_checks_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_https_health_checks_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HttpsHealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}',
    description=""" Deletes the specified HttpsHealthCheck resource. """,
    tags=['compute_health_checks_management', 'https_health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_https_health_checks_delete(
    project: str,
    https_health_check: str = Path(..., alias='httpsHealthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}',
    description=""" Returns the specified HttpsHealthCheck resource. """,
    tags=['https_health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_https_health_checks_get(
    project: str,
    https_health_check: str = Path(..., alias='httpsHealthCheck'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}',
    description=""" Updates a HttpsHealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=['https_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_https_health_checks_patch(
    project: str,
    https_health_check: str = Path(..., alias='httpsHealthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HttpsHealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}',
    description=""" Updates a HttpsHealthCheck resource in the specified project using the data included in the request. """,
    tags=['https_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_https_health_checks_update(
    project: str,
    https_health_check: str = Path(..., alias='httpsHealthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HttpsHealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/images',
    description=""" Retrieves the list of custom images available to the specified project. Custom images are images you create that belong to your project. This method does not get any images that belong to other projects, including publicly-available images, like Debian 8. If you want to get a list of publicly-available images, use this method to make a request to the respective image project, such as debian-cloud or windows-cloud. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/images',
    description=""" Creates an image in the specified project using the data included in the request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_insert(
    project: str,
    force_create: Optional[bool] = Query(None, alias='forceCreate'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Image = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/images/family/{family}',
    description=""" Returns the latest image that is part of an image family and is not deprecated. For more information on image families, see Public image families documentation. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_get_from_family(
    project: str,
    family: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/images/{image}',
    description=""" Deletes the specified image. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_image_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_delete(
    project: str,
    image: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/images/{image}',
    description=""" Returns the specified image. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_get(
    project: str,
    image: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/images/{image}',
    description=""" Patches the specified image with the data included in the request. Only the following fields can be modified: family, description, deprecation status. """,
    tags=['project_management_operations', 'compute_image_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_patch(
    project: str,
    image: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Image = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/images/{image}/deprecate',
    description=""" Sets the deprecation status of an image. If an empty request body is given, clears the deprecation status instead. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_deprecate(
    project: str,
    image: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: DeprecationStatus = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/images/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_get_iam_policy(
    project: str,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/images/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=[
        'project_management_operations',
        'firewall_management',
        'firewall_rule_management',
        'network_firewall_policy_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_set_iam_policy(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/images/{resource}/setLabels',
    description=""" Sets the labels on an image. To learn more about labels, read the Labeling Resources documentation. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_set_labels(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/images/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=[
        'firewall_policy_management',
        'firewall_policy_iam_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_images_test_iam_permissions(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/instanceTemplates',
    description=""" Retrieves a list of instance templates that are contained within the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_templates_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/instanceTemplates',
    description=""" Creates an instance template in the specified project using the data that is included in the request. If you are creating a new template to update an existing instance group, your new instance template must use the same network or, if applicable, the same subnetwork as the original template. """,
    tags=['compute_instance_template_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_templates_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceTemplate = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/instanceTemplates/{instanceTemplate}',
    description=""" Deletes the specified instance template. Deleting an instance template is permanent and cannot be undone. It is not possible to delete templates that are already in use by a managed instance group. """,
    tags=['compute_instance_template_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_templates_delete(
    project: str,
    instance_template: str = Path(..., alias='instanceTemplate'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/instanceTemplates/{instanceTemplate}',
    description=""" Returns the specified instance template. """,
    tags=['compute_instance_template_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_templates_get(
    project: str,
    instance_template: str = Path(..., alias='instanceTemplate'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/instanceTemplates/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_templates_get_iam_policy(
    project: str,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/instanceTemplates/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_templates_set_iam_policy(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/instanceTemplates/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['firewall_policy_iam_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_templates_test_iam_permissions(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/interconnectLocations',
    description=""" Retrieves the list of interconnect locations available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnect_locations_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/interconnectLocations/{interconnectLocation}',
    description=""" Returns the details for the specified interconnect location. Gets a list of available interconnect locations by making a list() request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnect_locations_get(
    project: str,
    interconnect_location: str = Path(..., alias='interconnectLocation'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/interconnects',
    description=""" Retrieves the list of Interconnects available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnects_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/interconnects',
    description=""" Creates an Interconnect in the specified project using the data included in the request. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnects_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Interconnect = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/interconnects/{interconnect}',
    description=""" Deletes the specified Interconnect. """,
    tags=['compute_interconnect_operations', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnects_delete(
    project: str,
    interconnect: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/interconnects/{interconnect}',
    description=""" Returns the specified Interconnect. Get a list of available Interconnects by making a list() request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnects_get(
    project: str,
    interconnect: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/interconnects/{interconnect}',
    description=""" Updates the specified Interconnect with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=['compute_interconnect_operations', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnects_patch(
    project: str,
    interconnect: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Interconnect = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/interconnects/{interconnect}/getDiagnostics',
    description=""" Returns the interconnectDiagnostics for the specified Interconnect. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnects_get_diagnostics(
    project: str,
    interconnect: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/interconnects/{resource}/setLabels',
    description=""" Sets the labels on an Interconnect. To learn more about labels, read the Labeling Resources documentation. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'global_operations_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnects_set_labels(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/licenseCodes/{licenseCode}',
    description=""" Return a specified license code. License codes are mirrored across all projects that have permissions to read the License Code. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.  """,
    tags=['project_license_management', 'license_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_license_codes_get(
    project: str,
    license_code: str = Path(..., alias='licenseCode'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/licenseCodes/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.  """,
    tags=[
        'firewall_policy_iam_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_license_codes_test_iam_permissions(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/licenses',
    description=""" Retrieves the list of licenses available in the specified project. This method does not get any licenses that belong to other projects, including licenses attached to publicly-available images, like Debian 9. If you want to get a list of publicly-available licenses, use this method to make a request to the respective image project, such as debian-cloud or windows-cloud. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.  """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_licenses_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/licenses',
    description=""" Create a License resource in the specified project. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.  """,
    tags=['project_license_management', 'license_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_licenses_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: License = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/licenses/{license}',
    description=""" Deletes the specified license. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.  """,
    tags=['project_license_management', 'license_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_licenses_delete(
    project: str,
    license: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/licenses/{license}',
    description=""" Returns the specified License resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.  """,
    tags=[
        'project_license_management',
        'license_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_licenses_get(
    project: str,
    license: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/licenses/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.  """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_licenses_get_iam_policy(
    project: str,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/licenses/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.  """,
    tags=['project_management_operations', 'global_operations_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_licenses_set_iam_policy(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/licenses/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.  """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_licenses_test_iam_permissions(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/machineImages',
    description=""" Retrieves a list of machine images that are contained within the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_machine_images_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/machineImages',
    description=""" Creates a machine image in the specified project using the data that is included in the request. If you are creating a new machine image to update an existing instance, your new machine image should use the same network or, if applicable, the same subnetwork as the original instance. """,
    tags=[
        'machine_image_management',
        'compute_image_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_machine_images_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    source_instance: Optional[str] = Query(None, alias='sourceInstance'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: MachineImage = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/machineImages/{machineImage}',
    description=""" Deletes the specified machine image. Deleting a machine image is permanent and cannot be undone. """,
    tags=['machine_image_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_machine_images_delete(
    project: str,
    machine_image: str = Path(..., alias='machineImage'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/machineImages/{machineImage}',
    description=""" Returns the specified machine image. """,
    tags=['machine_image_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_machine_images_get(
    project: str,
    machine_image: str = Path(..., alias='machineImage'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/machineImages/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_machine_images_get_iam_policy(
    project: str,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/machineImages/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['project_management_operations', 'global_operations_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_machine_images_set_iam_policy(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/machineImages/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_machine_images_test_iam_permissions(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/networkEndpointGroups',
    description=""" Retrieves the list of network endpoint groups that are located in the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_network_endpoint_groups_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/networkEndpointGroups',
    description=""" Creates a network endpoint group in the specified project using the parameters that are included in the request. """,
    tags=['network_endpoint_group_management', 'compute_network_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_network_endpoint_groups_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworkEndpointGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/networkEndpointGroups/{networkEndpointGroup}',
    description=""" Deletes the specified network endpoint group.Note that the NEG cannot be deleted if there are backend services referencing it. """,
    tags=['network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_network_endpoint_groups_delete(
    project: str,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/networkEndpointGroups/{networkEndpointGroup}',
    description=""" Returns the specified network endpoint group. """,
    tags=['network_endpoint_group_management', 'network_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_network_endpoint_groups_get(
    project: str,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/networkEndpointGroups/{networkEndpointGroup}/attachNetworkEndpoints',
    description=""" Attach a network endpoint to the specified network endpoint group. """,
    tags=['global_network_endpoint_management', 'network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_network_endpoint_groups_attach_network_endpoints(
    project: str,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalNetworkEndpointGroupsAttachEndpointsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/networkEndpointGroups/{networkEndpointGroup}/detachNetworkEndpoints',
    description=""" Detach the network endpoint from the specified network endpoint group. """,
    tags=['global_network_endpoint_management', 'network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_network_endpoint_groups_detach_network_endpoints(
    project: str,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalNetworkEndpointGroupsDetachEndpointsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/networkEndpointGroups/{networkEndpointGroup}/listNetworkEndpoints',
    description=""" Lists the network endpoints in the specified network endpoint group. """,
    tags=['network_endpoint_management', 'network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_network_endpoint_groups_list_network_endpoints(
    project: str,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/networks',
    description=""" Retrieves the list of networks available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/networks',
    description=""" Creates a network in the specified project using the data included in the request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Network = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/networks/{network}',
    description=""" Deletes the specified network. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_delete(
    project: str,
    network: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/networks/{network}',
    description=""" Returns the specified network. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_get(
    project: str,
    network: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/networks/{network}',
    description=""" Patches the specified network with the data included in the request. Only the following fields can be modified: routingConfig.routingMode. """,
    tags=['network_management', 'compute_network_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_patch(
    project: str,
    network: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Network = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/networks/{network}/addPeering',
    description=""" Adds a peering to the specified network. """,
    tags=['network_management', 'network_peering_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_add_peering(
    project: str,
    network: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworksAddPeeringRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/networks/{network}/getEffectiveFirewalls',
    description=""" Returns the effective firewalls on a given network. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_get_effective_firewalls(
    project: str,
    network: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/networks/{network}/listPeeringRoutes',
    description=""" Lists the peering routes exchanged over peering connection. """,
    tags=['network_management', 'network_peering_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_list_peering_routes(
    project: str,
    network: str = ...,
    direction: Optional[Direction3] = None,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    peering_name: Optional[str] = Query(None, alias='peeringName'),
    region: Optional[str] = None,
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/networks/{network}/removePeering',
    description=""" Removes a peering from the specified network. """,
    tags=['network_management', 'network_peering_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_remove_peering(
    project: str,
    network: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworksRemovePeeringRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/networks/{network}/switchToCustomMode',
    description=""" Switches the network mode from auto subnet mode to custom subnet mode. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_switch_to_custom_mode(
    project: str,
    network: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/networks/{network}/updatePeering',
    description=""" Updates the specified network peering with the data included in the request. You can only modify the NetworkPeering.export_custom_routes field and the NetworkPeering.import_custom_routes field. """,
    tags=['network_peering_management', 'network_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_networks_update_peering(
    project: str,
    network: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworksUpdatePeeringRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/operations',
    description=""" Retrieves a list of Operation resources contained within the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_operations_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/operations/{operation}',
    description=""" Deletes the specified Operations resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_operations_delete(
    project: str,
    operation: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/operations/{operation}',
    description=""" Retrieves the specified Operations resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_operations_get(
    project: str,
    operation: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/operations/{operation}/wait',
    description=""" Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method differs from the `GET` method in that it waits for no more than the default deadline (2 minutes) and then returns the current state of the operation, which might be `DONE` or still in progress. This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.  """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_operations_wait(
    project: str,
    operation: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/publicAdvertisedPrefixes',
    description=""" Lists the PublicAdvertisedPrefixes for a project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_advertised_prefixes_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/publicAdvertisedPrefixes',
    description=""" Creates a PublicAdvertisedPrefix in the specified project using the parameters that are included in the request. """,
    tags=['advertised_prefix_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_advertised_prefixes_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: PublicAdvertisedPrefix = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/publicAdvertisedPrefixes/{publicAdvertisedPrefix}',
    description=""" Deletes the specified PublicAdvertisedPrefix """,
    tags=[
        'project_management_operations',
        'advertised_prefix_management',
        'public_delegated_prefix_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_advertised_prefixes_delete(
    project: str,
    public_advertised_prefix: str = Path(..., alias='publicAdvertisedPrefix'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/publicAdvertisedPrefixes/{publicAdvertisedPrefix}',
    description=""" Returns the specified PublicAdvertisedPrefix resource. """,
    tags=['advertised_prefix_management', 'public_delegated_prefix_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_advertised_prefixes_get(
    project: str,
    public_advertised_prefix: str = Path(..., alias='publicAdvertisedPrefix'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/publicAdvertisedPrefixes/{publicAdvertisedPrefix}',
    description=""" Patches the specified Router resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=['advertised_prefix_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_advertised_prefixes_patch(
    project: str,
    public_advertised_prefix: str = Path(..., alias='publicAdvertisedPrefix'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: PublicAdvertisedPrefix = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/publicDelegatedPrefixes',
    description=""" Lists the global PublicDelegatedPrefixes for a project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_public_delegated_prefixes_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/publicDelegatedPrefixes',
    description=""" Creates a global PublicDelegatedPrefix in the specified project using the parameters that are included in the request. """,
    tags=['public_delegated_prefix_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_public_delegated_prefixes_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: PublicDelegatedPrefix = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}',
    description=""" Deletes the specified global PublicDelegatedPrefix. """,
    tags=['public_delegated_prefix_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_public_delegated_prefixes_delete(
    project: str,
    public_delegated_prefix: str = Path(..., alias='publicDelegatedPrefix'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}',
    description=""" Returns the specified global PublicDelegatedPrefix resource. """,
    tags=['public_delegated_prefix_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_public_delegated_prefixes_get(
    project: str,
    public_delegated_prefix: str = Path(..., alias='publicDelegatedPrefix'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}',
    description=""" Patches the specified global PublicDelegatedPrefix resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=['public_delegated_prefix_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_global_public_delegated_prefixes_patch(
    project: str,
    public_delegated_prefix: str = Path(..., alias='publicDelegatedPrefix'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: PublicDelegatedPrefix = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/routes',
    description=""" Retrieves the list of Route resources available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routes_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/routes',
    description=""" Creates a Route resource in the specified project using the data included in the request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routes_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Route = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/routes/{route}',
    description=""" Deletes the specified Route resource. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routes_delete(
    project: str,
    route: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/routes/{route}',
    description=""" Returns the specified Route resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routes_get(
    project: str,
    route: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/securityPolicies',
    description=""" List all the policies that have been configured for the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/securityPolicies',
    description=""" Creates a new policy in the specified project using the data included in the request. """,
    tags=[
        'security_policy_management',
        'firewall_policy_management',
        'compute_security_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    validate_only: Optional[bool] = Query(None, alias='validateOnly'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SecurityPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/securityPolicies/listPreconfiguredExpressionSets',
    description=""" Gets the current list of preconfigured Web Application Firewall (WAF) expressions. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_list_preconfigured_expression_sets(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/securityPolicies/{resource}/setLabels',
    description=""" Sets the labels on a security policy. To learn more about labels, read the Labeling Resources documentation. """,
    tags=['project_management_operations', 'global_operations_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_set_labels(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/securityPolicies/{securityPolicy}',
    description=""" Deletes the specified policy. """,
    tags=['security_policy_management', 'firewall_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_delete(
    project: str,
    security_policy: str = Path(..., alias='securityPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/securityPolicies/{securityPolicy}',
    description=""" List all of the ordered rules present in a single specified policy. """,
    tags=['security_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_get(
    project: str,
    security_policy: str = Path(..., alias='securityPolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/securityPolicies/{securityPolicy}',
    description=""" Patches the specified policy with the data included in the request. To clear fields in the rule, leave the fields empty and specify them in the updateMask. This cannot be used to be update the rules in the policy. Please use the per rule methods like addRule, patchRule, and removeRule instead. """,
    tags=['security_policy_management', 'backend_security_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_patch(
    project: str,
    security_policy: str = Path(..., alias='securityPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SecurityPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/securityPolicies/{securityPolicy}/addRule',
    description=""" Inserts a rule into a security policy. """,
    tags=['security_policy_management', 'firewall_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_add_rule(
    project: str,
    security_policy: str = Path(..., alias='securityPolicy'),
    validate_only: Optional[bool] = Query(None, alias='validateOnly'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SecurityPolicyRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/securityPolicies/{securityPolicy}/getRule',
    description=""" Gets a rule at the specified priority. """,
    tags=['security_policy_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_get_rule(
    project: str,
    security_policy: str = Path(..., alias='securityPolicy'),
    priority: Optional[int] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/securityPolicies/{securityPolicy}/patchRule',
    description=""" Patches a rule at the specified priority. """,
    tags=[
        'security_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_patch_rule(
    project: str,
    security_policy: str = Path(..., alias='securityPolicy'),
    priority: Optional[int] = None,
    validate_only: Optional[bool] = Query(None, alias='validateOnly'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SecurityPolicyRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/securityPolicies/{securityPolicy}/removeRule',
    description=""" Deletes a rule at the specified priority. """,
    tags=['security_policy_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_security_policies_remove_rule(
    project: str,
    security_policy: str = Path(..., alias='securityPolicy'),
    priority: Optional[int] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/snapshots',
    description=""" Retrieves the list of Snapshot resources contained within the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_snapshots_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/snapshots',
    description=""" Creates a snapshot in the specified project using the data included in the request. For regular snapshot creation, consider using this method instead of disks.createSnapshot, as this method supports more features, such as creating snapshots in a project different from the source disk project. """,
    tags=['project_management_operations', 'snapshot_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_snapshots_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Snapshot = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/snapshots/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'resource_aggregated_lists',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_snapshots_get_iam_policy(
    project: str,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/snapshots/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['project_management_operations', 'global_operations_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_snapshots_set_iam_policy(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/snapshots/{resource}/setLabels',
    description=""" Sets the labels on a snapshot. To learn more about labels, read the Labeling Resources documentation. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_snapshots_set_labels(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GlobalSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/snapshots/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['firewall_policy_iam_management', 'firewall_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_snapshots_test_iam_permissions(
    project: str,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/snapshots/{snapshot}',
    description=""" Deletes the specified Snapshot resource. Keep in mind that deleting a single snapshot might not necessarily delete all the data on that snapshot. If any data on the snapshot that is marked for deletion is needed for subsequent snapshots, the data will be moved to the next corresponding snapshot. For more information, see Deleting snapshots. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_snapshots_delete(
    project: str,
    snapshot: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/snapshots/{snapshot}',
    description=""" Returns the specified Snapshot resource. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_snapshots_get(
    project: str,
    snapshot: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/sslCertificates',
    description=""" Retrieves the list of SslCertificate resources available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_certificates_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/sslCertificates',
    description=""" Creates a SslCertificate resource in the specified project using the data included in the request. """,
    tags=['ssl_certificate_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_certificates_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SslCertificate = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/sslCertificates/{sslCertificate}',
    description=""" Deletes the specified SslCertificate resource. """,
    tags=['ssl_certificate_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_certificates_delete(
    project: str,
    ssl_certificate: str = Path(..., alias='sslCertificate'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/sslCertificates/{sslCertificate}',
    description=""" Returns the specified SslCertificate resource. """,
    tags=['ssl_certificate_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_certificates_get(
    project: str,
    ssl_certificate: str = Path(..., alias='sslCertificate'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/sslPolicies',
    description=""" Lists all the SSL policies that have been configured for the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_policies_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/sslPolicies',
    description=""" Returns the specified SSL policy resource. """,
    tags=['ssl_policy_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_policies_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SslPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/sslPolicies/listAvailableFeatures',
    description=""" Lists all features that can be specified in the SSL policy when using custom profile. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_policies_list_available_features(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/sslPolicies/{sslPolicy}',
    description=""" Deletes the specified SSL policy. The SSL policy resource can be deleted only if it is not in use by any TargetHttpsProxy or TargetSslProxy resources. """,
    tags=['ssl_policy_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_policies_delete(
    project: str,
    ssl_policy: str = Path(..., alias='sslPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/sslPolicies/{sslPolicy}',
    description=""" Lists all of the ordered rules present in a single specified policy. """,
    tags=['ssl_policy_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_policies_get(
    project: str,
    ssl_policy: str = Path(..., alias='sslPolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/sslPolicies/{sslPolicy}',
    description=""" Patches the specified SSL policy with the data included in the request. """,
    tags=['ssl_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_ssl_policies_patch(
    project: str,
    ssl_policy: str = Path(..., alias='sslPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SslPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/targetGrpcProxies',
    description=""" Lists the TargetGrpcProxies for a project in the given scope. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_grpc_proxies_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetGrpcProxies',
    description=""" Creates a TargetGrpcProxy in the specified project in the given scope using the parameters that are included in the request. """,
    tags=[
        'target_proxy_operations',
        'grpc_proxy_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_grpc_proxies_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetGrpcProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}',
    description=""" Deletes the specified TargetGrpcProxy in the given scope """,
    tags=['grpc_proxy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_grpc_proxies_delete(
    project: str,
    target_grpc_proxy: str = Path(..., alias='targetGrpcProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}',
    description=""" Returns the specified TargetGrpcProxy resource in the given scope. """,
    tags=[
        'target_proxy_operations',
        'grpc_proxy_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_grpc_proxies_get(
    project: str,
    target_grpc_proxy: str = Path(..., alias='targetGrpcProxy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}',
    description=""" Patches the specified TargetGrpcProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=['grpc_proxy_management', 'target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_grpc_proxies_patch(
    project: str,
    target_grpc_proxy: str = Path(..., alias='targetGrpcProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetGrpcProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/targetHttpProxies',
    description=""" Retrieves the list of TargetHttpProxy resources available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_http_proxies_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetHttpProxies',
    description=""" Creates a TargetHttpProxy resource in the specified project using the data included in the request. """,
    tags=['project_management_operations', 'target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_http_proxies_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetHttpProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/targetHttpProxies/{targetHttpProxy}',
    description=""" Deletes the specified TargetHttpProxy resource. """,
    tags=['target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_http_proxies_delete(
    project: str,
    target_http_proxy: str = Path(..., alias='targetHttpProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/targetHttpProxies/{targetHttpProxy}',
    description=""" Returns the specified TargetHttpProxy resource. """,
    tags=['project_management_operations', 'target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_http_proxies_get(
    project: str,
    target_http_proxy: str = Path(..., alias='targetHttpProxy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/targetHttpProxies/{targetHttpProxy}',
    description=""" Patches the specified TargetHttpProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=['target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_http_proxies_patch(
    project: str,
    target_http_proxy: str = Path(..., alias='targetHttpProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetHttpProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/targetHttpsProxies',
    description=""" Retrieves the list of TargetHttpsProxy resources available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetHttpsProxies',
    description=""" Creates a TargetHttpsProxy resource in the specified project using the data included in the request. """,
    tags=['project_management_operations', 'target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetHttpsProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}',
    description=""" Deletes the specified TargetHttpsProxy resource. """,
    tags=['target_https_proxy_operations', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_delete(
    project: str,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}',
    description=""" Returns the specified TargetHttpsProxy resource. """,
    tags=['target_proxy_operations', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_get(
    project: str,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}',
    description=""" Patches the specified TargetHttpsProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=['target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_patch(
    project: str,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetHttpsProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}/setCertificateMap',
    description=""" Changes the Certificate Map for TargetHttpsProxy. """,
    tags=['https_proxy_management', 'target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_set_certificate_map(
    project: str,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetHttpsProxiesSetCertificateMapRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}/setQuicOverride',
    description=""" Sets the QUIC override policy for TargetHttpsProxy. """,
    tags=['target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_set_quic_override(
    project: str,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetHttpsProxiesSetQuicOverrideRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}/setSslPolicy',
    description=""" Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the server-side support for SSL features. This affects connections between clients and the HTTPS proxy load balancer. They do not affect the connection between the load balancer and the backends. """,
    tags=['ssl_policy_management', 'https_proxy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_set_ssl_policy(
    project: str,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SslPolicyReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/targetSslProxies',
    description=""" Retrieves the list of TargetSslProxy resources available to the specified project. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'global_operations_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_ssl_proxies_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetSslProxies',
    description=""" Creates a TargetSslProxy resource in the specified project using the data included in the request. """,
    tags=['target_proxy_operations', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_ssl_proxies_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetSslProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/targetSslProxies/{targetSslProxy}',
    description=""" Deletes the specified TargetSslProxy resource. """,
    tags=['target_proxy_operations', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_ssl_proxies_delete(
    project: str,
    target_ssl_proxy: str = Path(..., alias='targetSslProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/targetSslProxies/{targetSslProxy}',
    description=""" Returns the specified TargetSslProxy resource. """,
    tags=['target_proxy_operations', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_ssl_proxies_get(
    project: str,
    target_ssl_proxy: str = Path(..., alias='targetSslProxy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetSslProxies/{targetSslProxy}/setBackendService',
    description=""" Changes the BackendService for TargetSslProxy. """,
    tags=['backend_service_management', 'target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_ssl_proxies_set_backend_service(
    project: str,
    target_ssl_proxy: str = Path(..., alias='targetSslProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetSslProxiesSetBackendServiceRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetSslProxies/{targetSslProxy}/setCertificateMap',
    description=""" Changes the Certificate Map for TargetSslProxy. """,
    tags=['target_proxy_operations', 'ssl_certificate_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_ssl_proxies_set_certificate_map(
    project: str,
    target_ssl_proxy: str = Path(..., alias='targetSslProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetSslProxiesSetCertificateMapRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetSslProxies/{targetSslProxy}/setProxyHeader',
    description=""" Changes the ProxyHeaderType for TargetSslProxy. """,
    tags=['target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_ssl_proxies_set_proxy_header(
    project: str,
    target_ssl_proxy: str = Path(..., alias='targetSslProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetSslProxiesSetProxyHeaderRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetSslProxies/{targetSslProxy}/setSslCertificates',
    description=""" Changes SslCertificates for TargetSslProxy. """,
    tags=[
        'ssl_certificate_management',
        'http_proxy_management',
        'tcp_proxy_management',
        'target_proxy_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_ssl_proxies_set_ssl_certificates(
    project: str,
    target_ssl_proxy: str = Path(..., alias='targetSslProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetSslProxiesSetSslCertificatesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetSslProxies/{targetSslProxy}/setSslPolicy',
    description=""" Sets the SSL policy for TargetSslProxy. The SSL policy specifies the server-side support for SSL features. This affects connections between clients and the SSL proxy load balancer. They do not affect the connection between the load balancer and the backends. """,
    tags=['ssl_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_ssl_proxies_set_ssl_policy(
    project: str,
    target_ssl_proxy: str = Path(..., alias='targetSslProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SslPolicyReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/targetTcpProxies',
    description=""" Retrieves the list of TargetTcpProxy resources available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_tcp_proxies_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetTcpProxies',
    description=""" Creates a TargetTcpProxy resource in the specified project using the data included in the request. """,
    tags=['target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_tcp_proxies_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetTcpProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/targetTcpProxies/{targetTcpProxy}',
    description=""" Deletes the specified TargetTcpProxy resource. """,
    tags=['target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_tcp_proxies_delete(
    project: str,
    target_tcp_proxy: str = Path(..., alias='targetTcpProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/targetTcpProxies/{targetTcpProxy}',
    description=""" Returns the specified TargetTcpProxy resource. """,
    tags=['target_proxy_operations', 'tcp_proxy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_tcp_proxies_get(
    project: str,
    target_tcp_proxy: str = Path(..., alias='targetTcpProxy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetTcpProxies/{targetTcpProxy}/setBackendService',
    description=""" Changes the BackendService for TargetTcpProxy. """,
    tags=['target_proxy_operations', 'backend_service_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_tcp_proxies_set_backend_service(
    project: str,
    target_tcp_proxy: str = Path(..., alias='targetTcpProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetTcpProxiesSetBackendServiceRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/targetTcpProxies/{targetTcpProxy}/setProxyHeader',
    description=""" Changes the ProxyHeaderType for TargetTcpProxy. """,
    tags=['target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_tcp_proxies_set_proxy_header(
    project: str,
    target_tcp_proxy: str = Path(..., alias='targetTcpProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetTcpProxiesSetProxyHeaderRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/urlMaps',
    description=""" Retrieves the list of UrlMap resources available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_url_maps_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/urlMaps',
    description=""" Creates a UrlMap resource in the specified project using the data included in the request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_url_maps_insert(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMap = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/global/urlMaps/{urlMap}',
    description=""" Deletes the specified UrlMap resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_url_maps_delete(
    project: str,
    url_map: str = Path(..., alias='urlMap'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/global/urlMaps/{urlMap}',
    description=""" Returns the specified UrlMap resource. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_url_maps_get(
    project: str,
    url_map: str = Path(..., alias='urlMap'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/global/urlMaps/{urlMap}',
    description=""" Patches the specified UrlMap resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_url_maps_patch(
    project: str,
    url_map: str = Path(..., alias='urlMap'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMap = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/global/urlMaps/{urlMap}',
    description=""" Updates the specified UrlMap resource with the data included in the request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_url_maps_update(
    project: str,
    url_map: str = Path(..., alias='urlMap'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMap = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/urlMaps/{urlMap}/invalidateCache',
    description=""" Initiates a cache invalidation operation, invalidating the specified path, scoped to the specified UrlMap. For more information, see [Invalidating cached content](/cdn/docs/invalidating-cached-content). """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_url_maps_invalidate_cache(
    project: str,
    url_map: str = Path(..., alias='urlMap'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: CacheInvalidationRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/global/urlMaps/{urlMap}/validate',
    description=""" Runs static validation for the UrlMap. In particular, the tests of the provided UrlMap will be run. Calling this method does NOT create the UrlMap. """,
    tags=['project_management_operations', 'resource_aggregated_lists'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_url_maps_validate(
    project: str,
    url_map: str = Path(..., alias='urlMap'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMapsValidateRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/listXpnHosts',
    description=""" Lists all shared VPC host projects visible to the user in an organization. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_list_xpn_hosts(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ProjectsListXpnHostsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/moveDisk',
    description=""" Moves a persistent disk from one zone to another. """,
    tags=['disk_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_move_disk(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: DiskMoveRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/moveInstance',
    description=""" Moves an instance and its attached persistent disks from one zone to another. *Note*: Moving VMs or disks by using this method might cause unexpected behavior. For more information, see the [known issue](/compute/docs/troubleshooting/known-issues#moving_vms_or_disks_using_the_moveinstance_api_or_the_causes_unexpected_behavior). """,
    tags=[
        'compute_instance_management',
        'instance_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_move_instance(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceMoveRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions',
    description=""" Retrieves the list of region resources available to the specified project. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is especially recommended for unused quota information (the `items.quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need. For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_regions_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}',
    description=""" Returns the specified Region resource. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is especially recommended for unused quota information (the `quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need. For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_regions_get(
    project: str,
    region: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/addresses',
    description=""" Retrieves a list of addresses contained within the specified region. """,
    tags=[
        'project_retrieval',
        'global_operations_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_addresses_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/addresses',
    description=""" Creates an address resource in the specified project by using the data included in the request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_addresses_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Address = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/addresses/{address}',
    description=""" Deletes the specified address resource. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_addresses_delete(
    project: str,
    region: str = ...,
    address: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/addresses/{address}',
    description=""" Returns the specified address resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_addresses_get(
    project: str,
    region: str = ...,
    address: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/addresses/{resource}/setLabels',
    description=""" Sets the labels on an Address. To learn more about labels, read the Labeling Resources documentation. """,
    tags=[
        'project_management_operations',
        'subnetwork_operations',
        'network_management',
        'resource_aggregated_lists',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_addresses_set_labels(
    project: str,
    region: str = ...,
    resource: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/autoscalers',
    description=""" Retrieves a list of autoscalers contained within the specified region. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_autoscalers_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/autoscalers',
    description=""" Updates an autoscaler in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=['resource_aggregated_lists', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_autoscalers_patch(
    project: str,
    region: str = ...,
    autoscaler: Optional[str] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Autoscaler = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/autoscalers',
    description=""" Creates an autoscaler in the specified project using the data included in the request. """,
    tags=['resource_aggregated_lists', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_autoscalers_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Autoscaler = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/regions/{region}/autoscalers',
    description=""" Updates an autoscaler in the specified project using the data included in the request. """,
    tags=['resource_aggregated_lists', 'compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_autoscalers_update(
    project: str,
    region: str = ...,
    autoscaler: Optional[str] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Autoscaler = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/autoscalers/{autoscaler}',
    description=""" Deletes the specified autoscaler. """,
    tags=[
        'project_management_operations',
        'resource_aggregated_lists',
        'project_retrieval',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_autoscalers_delete(
    project: str,
    region: str = ...,
    autoscaler: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/autoscalers/{autoscaler}',
    description=""" Returns the specified autoscaler. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_autoscalers_get(
    project: str,
    region: str = ...,
    autoscaler: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/backendServices',
    description=""" Retrieves the list of regional BackendService resources available to the specified project in the given region. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_backend_services_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/backendServices',
    description=""" Creates a regional BackendService resource in the specified project using the data included in the request. For more information, see Backend services overview. """,
    tags=[
        'backend_service_management',
        'backend_service_health_checks',
        'backend_security_policy_management',
        'backend_iam_policy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_backend_services_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BackendService = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/backendServices/{backendService}',
    description=""" Deletes the specified regional BackendService resource. """,
    tags=['backend_service_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_backend_services_delete(
    project: str,
    region: str = ...,
    backend_service: str = Path(..., alias='backendService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/backendServices/{backendService}',
    description=""" Returns the specified regional BackendService resource. """,
    tags=['backend_service_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_backend_services_get(
    project: str,
    region: str = ...,
    backend_service: str = Path(..., alias='backendService'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/backendServices/{backendService}',
    description=""" Updates the specified regional BackendService resource with the data included in the request. For more information, see Understanding backend services This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=[
        'backend_service_management',
        'resource_aggregated_lists',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_backend_services_patch(
    project: str,
    region: str = ...,
    backend_service: str = Path(..., alias='backendService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BackendService = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/regions/{region}/backendServices/{backendService}',
    description=""" Updates the specified regional BackendService resource with the data included in the request. For more information, see Backend services overview . """,
    tags=['backend_service_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_backend_services_update(
    project: str,
    region: str = ...,
    backend_service: str = Path(..., alias='backendService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BackendService = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/backendServices/{backendService}/getHealth',
    description=""" Gets the most recent health check results for this regional BackendService. """,
    tags=['backend_service_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_backend_services_get_health(
    project: str,
    region: str = ...,
    backend_service: str = Path(..., alias='backendService'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ResourceGroupReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/backendServices/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_backend_services_get_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/backendServices/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['network_firewall_policy_management', 'firewall_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_backend_services_set_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/commitments',
    description=""" Retrieves a list of commitments contained within the specified region. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_commitments_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/commitments',
    description=""" Creates a commitment in the specified project using the data included in the request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_commitments_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Commitment = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/commitments/{commitment}',
    description=""" Returns the specified commitment resource. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_commitments_get(
    project: str,
    region: str = ...,
    commitment: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/commitments/{commitment}',
    description=""" Updates the specified commitment with the data included in the request. Update is performed only on selected fields included as part of update-mask. Only the following fields can be modified: auto_renew. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_commitments_update(
    project: str,
    region: str = ...,
    commitment: str = ...,
    paths: Optional[Paths] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Commitment = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/diskTypes',
    description=""" Retrieves a list of regional disk types available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disk_types_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/diskTypes/{diskType}',
    description=""" Returns the specified regional disk type. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disk_types_get(
    project: str,
    region: str = ...,
    disk_type: str = Path(..., alias='diskType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/disks',
    description=""" Retrieves the list of persistent disks contained within the specified region. """,
    tags=[
        'project_retrieval',
        'project_management_operations',
        'global_operations_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/disks',
    description=""" Creates a persistent regional disk in the specified project using the data included in the request. """,
    tags=[
        'disk_management',
        'compute_resource_management',
        'compute_image_management',
        'compute_instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    source_image: Optional[str] = Query(None, alias='sourceImage'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Disk = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/disks/{disk}',
    description=""" Deletes the specified regional persistent disk. Deleting a regional disk removes all the replicas of its data permanently and is irreversible. However, deleting a disk does not delete any snapshots previously made from the disk. You must separately delete snapshots. """,
    tags=['compute_instance_management', 'disk_management', 'instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_delete(
    project: str,
    region: str = ...,
    disk: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/disks/{disk}',
    description=""" Returns a specified regional persistent disk. """,
    tags=[
        'project_management_operations',
        'disk_management',
        'compute_instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_get(
    project: str,
    region: str = ...,
    disk: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/disks/{disk}',
    description=""" Update the specified disk with the data included in the request. Update is performed only on selected fields included as part of update-mask. Only the following fields can be modified: user_license. """,
    tags=[
        'disk_management',
        'compute_resource_management',
        'compute_instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_update(
    project: str,
    region: str = ...,
    disk: str = ...,
    paths: Optional[Paths] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Disk = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/disks/{disk}/addResourcePolicies',
    description=""" Adds existing resource policies to a regional disk. You can only add one policy which will be applied to this disk for scheduling snapshot creation. """,
    tags=['disk_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_add_resource_policies(
    project: str,
    region: str = ...,
    disk: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionDisksAddResourcePoliciesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/disks/{disk}/createSnapshot',
    description=""" Creates a snapshot of a specified persistent disk. For regular snapshot creation, consider using snapshots.insert instead, as that method supports more features, such as creating snapshots in a project different from the source disk project. """,
    tags=['snapshot_management', 'disk_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_create_snapshot(
    project: str,
    region: str = ...,
    disk: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Snapshot = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/disks/{disk}/removeResourcePolicies',
    description=""" Removes resource policies from a regional disk. """,
    tags=['disk_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_remove_resource_policies(
    project: str,
    region: str = ...,
    disk: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionDisksRemoveResourcePoliciesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/disks/{disk}/resize',
    description=""" Resizes the specified regional persistent disk. """,
    tags=['disk_management', 'zone_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_resize(
    project: str,
    region: str = ...,
    disk: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionDisksResizeRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/disks/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_get_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/disks/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_set_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/disks/{resource}/setLabels',
    description=""" Sets the labels on the target regional disk. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_set_labels(
    project: str,
    region: str = ...,
    resource: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/disks/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_disks_test_iam_permissions(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/firewallPolicies',
    description=""" Lists all the network firewall policies that have been configured for the specified project in the given region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/firewallPolicies',
    description=""" Creates a new network firewall policy in the specified project and region. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_rule_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/firewallPolicies/getEffectiveFirewalls',
    description=""" Returns the effective firewalls on a given network. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_get_effective_firewalls(
    project: str,
    region: str = ...,
    network: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}',
    description=""" Deletes the specified network firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_delete(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}',
    description=""" Returns the specified network firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_policy_iam_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_get(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}',
    description=""" Patches the specified network firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_patch(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/addAssociation',
    description=""" Inserts an association for the specified network firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_add_association(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    replace_existing_association: Optional[bool] = Query(
        None, alias='replaceExistingAssociation'
    ),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicyAssociation = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/addRule',
    description=""" Inserts a rule into a network firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_rule_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_add_rule(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    max_priority: Optional[int] = Query(None, alias='maxPriority'),
    min_priority: Optional[int] = Query(None, alias='minPriority'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicyRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/cloneRules',
    description=""" Copies rules to the specified network firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_clone_rules(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    source_firewall_policy: Optional[str] = Query(None, alias='sourceFirewallPolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/getAssociation',
    description=""" Gets an association with the specified name. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_get_association(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    name: Optional[str] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/getRule',
    description=""" Gets a rule of the specified priority. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_policy_iam_management',
        'firewall_rule_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_get_rule(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    priority: Optional[int] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/patchRule',
    description=""" Patches a rule of the specified priority. """,
    tags=[
        'firewall_policy_management',
        'firewall_rule_management',
        'firewall_management',
        'network_firewall_policy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_patch_rule(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    priority: Optional[int] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FirewallPolicyRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/removeAssociation',
    description=""" Removes an association for the specified network firewall policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_remove_association(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    name: Optional[str] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/removeRule',
    description=""" Deletes a rule of the specified priority. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_remove_rule(
    project: str,
    region: str = ...,
    firewall_policy: str = Path(..., alias='firewallPolicy'),
    priority: Optional[int] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/firewallPolicies/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_get_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/firewallPolicies/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=[
        'project_management_operations',
        'network_firewall_policy_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_set_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/firewallPolicies/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_firewall_policies_test_iam_permissions(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/forwardingRules',
    description=""" Retrieves a list of ForwardingRule resources available to the specified project and region. """,
    tags=[
        'project_retrieval',
        'global_operations_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_forwarding_rules_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/forwardingRules',
    description=""" Creates a ForwardingRule resource in the specified project and region using the data included in the request. """,
    tags=['project_management_operations', 'global_operations_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_forwarding_rules_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ForwardingRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/forwardingRules/{forwardingRule}',
    description=""" Deletes the specified ForwardingRule resource. """,
    tags=['global_forwarding_rules_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_forwarding_rules_delete(
    project: str,
    region: str = ...,
    forwarding_rule: str = Path(..., alias='forwardingRule'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/forwardingRules/{forwardingRule}',
    description=""" Returns the specified ForwardingRule resource. """,
    tags=['global_forwarding_rules_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_forwarding_rules_get(
    project: str,
    region: str = ...,
    forwarding_rule: str = Path(..., alias='forwardingRule'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/forwardingRules/{forwardingRule}',
    description=""" Updates the specified forwarding rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. Currently, you can only patch the network_tier field. """,
    tags=['global_forwarding_rules_management', 'compute_network_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_forwarding_rules_patch(
    project: str,
    region: str = ...,
    forwarding_rule: str = Path(..., alias='forwardingRule'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ForwardingRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/forwardingRules/{forwardingRule}/setTarget',
    description=""" Changes target URL for forwarding rule. The new target should be of the same type as the old target. """,
    tags=['global_forwarding_rules_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_forwarding_rules_set_target(
    project: str,
    region: str = ...,
    forwarding_rule: str = Path(..., alias='forwardingRule'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/forwardingRules/{resource}/setLabels',
    description=""" Sets the labels on the specified resource. To learn more about labels, read the Labeling Resources documentation. """,
    tags=['resource_aggregated_lists', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_forwarding_rules_set_labels(
    project: str,
    region: str = ...,
    resource: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/healthCheckServices',
    description=""" Lists all the HealthCheckService resources that have been configured for the specified project in the given region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_check_services_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/healthCheckServices',
    description=""" Creates a regional HealthCheckService resource in the specified project and region using the data included in the request. """,
    tags=['compute_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_check_services_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HealthCheckService = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/healthCheckServices/{healthCheckService}',
    description=""" Deletes the specified regional HealthCheckService. """,
    tags=[
        'compute_health_checks_management',
        'health_checks_management',
        'http_health_checks_management',
        'https_health_checks_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_check_services_delete(
    project: str,
    region: str = ...,
    health_check_service: str = Path(..., alias='healthCheckService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/healthCheckServices/{healthCheckService}',
    description=""" Returns the specified regional HealthCheckService resource. """,
    tags=['compute_health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_check_services_get(
    project: str,
    region: str = ...,
    health_check_service: str = Path(..., alias='healthCheckService'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/healthCheckServices/{healthCheckService}',
    description=""" Updates the specified regional HealthCheckService resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=[
        'compute_health_checks_management',
        'health_checks_management',
        'http_health_checks_management',
        'https_health_checks_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_check_services_patch(
    project: str,
    region: str = ...,
    health_check_service: str = Path(..., alias='healthCheckService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HealthCheckService = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/healthChecks',
    description=""" Retrieves the list of HealthCheck resources available to the specified project. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_checks_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/healthChecks',
    description=""" Creates a HealthCheck resource in the specified project using the data included in the request. """,
    tags=['compute_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_checks_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/healthChecks/{healthCheck}',
    description=""" Deletes the specified HealthCheck resource. """,
    tags=[
        'compute_health_checks_management',
        'health_checks_management',
        'http_health_checks_management',
        'https_health_checks_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_checks_delete(
    project: str,
    region: str = ...,
    health_check: str = Path(..., alias='healthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/healthChecks/{healthCheck}',
    description=""" Returns the specified HealthCheck resource. """,
    tags=['compute_health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_checks_get(
    project: str,
    region: str = ...,
    health_check: str = Path(..., alias='healthCheck'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/healthChecks/{healthCheck}',
    description=""" Updates a HealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=['compute_health_checks_management', 'health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_checks_patch(
    project: str,
    region: str = ...,
    health_check: str = Path(..., alias='healthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/regions/{region}/healthChecks/{healthCheck}',
    description=""" Updates a HealthCheck resource in the specified project using the data included in the request. """,
    tags=[
        'compute_health_checks_management',
        'health_checks_management',
        'backend_service_health_checks',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_health_checks_update(
    project: str,
    region: str = ...,
    health_check: str = Path(..., alias='healthCheck'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HealthCheck = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/instanceGroupManagers',
    description=""" Retrieves the list of managed instance groups that are contained within the specified region. """,
    tags=[
        'project_retrieval',
        'project_management_operations',
        'global_operations_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers',
    description=""" Creates a managed instance group using the information that you specify in the request. After the group is created, instances in the group are created using the specified instance template. This operation is marked as DONE when the group is created even if the instances in the group have not yet been created. You must separately verify the status of the individual instances with the listmanagedinstances method. A regional managed instance group can contain up to 2000 instances. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManager = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}',
    description=""" Deletes the specified managed instance group and all of the instances in that group. """,
    tags=['compute_instance_groups_management', 'compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_delete(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}',
    description=""" Returns all of the details about the specified managed instance group. """,
    tags=[
        'compute_instance_groups_management',
        'project_management_operations',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_get(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}',
    description=""" Updates a managed instance group using the information that you specify in the request. This operation is marked as DONE when the group is patched even if the instances in the group are still in the process of being patched. You must separately verify the status of the individual instances with the listmanagedinstances method. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. If you update your group to specify a new template or instance configuration, it's possible that your intended specification for each VM in the group is different from the current state of that VM. To learn how to apply an updated configuration to the VMs in a MIG, see Updating instances in a MIG. """,
    tags=[
        'compute_instance_groups_management',
        'instance_management',
        'network_endpoint_group_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_patch(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManager = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/abandonInstances',
    description=""" Flags the specified instances to be immediately removed from the managed instance group. Abandoning an instance does not delete the instance, but it does remove the instance from any target pools that are applied by the managed instance group. This method reduces the targetSize of the managed instance group by the number of instances that you abandon. This operation is marked as DONE when the action is scheduled even if the instances have not yet been removed from the group. You must separately verify the status of the abandoning action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request. """,
    tags=['compute_instance_groups_management', 'instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_abandon_instances(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupManagersAbandonInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances',
    description=""" Apply updates to selected instances the managed instance group. """,
    tags=['compute_instance_groups_management', 'compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def apply_updates_to_instance_group_manager(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupManagersApplyUpdatesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/createInstances',
    description=""" Creates instances with per-instance configurations in this regional managed instance group. Instances are created using the current instance template. The create instances operation is marked DONE if the createInstances request is successful. The underlying actions take additional time. You must separately verify the status of the creating or actions with the listmanagedinstances method. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_create_instances(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupManagersCreateInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/deleteInstances',
    description=""" Flags the specified instances in the managed instance group to be immediately deleted. The instances are also removed from any target pools of which they were a member. This method reduces the targetSize of the managed instance group by the number of instances that you delete. The deleteInstances operation is marked DONE if the deleteInstances request is successful. The underlying actions take additional time. You must separately verify the status of the deleting action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request. """,
    tags=['compute_instance_groups_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_delete_instances(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupManagersDeleteInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/deletePerInstanceConfigs',
    description=""" Deletes selected per-instance configurations for the managed instance group. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_instance_group_manager_configs(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupManagerDeleteInstanceConfigReq = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/listErrors',
    description=""" Lists all errors thrown by actions on instances for a given regional managed instance group. The filter and orderBy query parameters are not supported. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_list_errors(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/listManagedInstances',
    description=""" Lists the instances in the managed instance group and instances that are scheduled to be created. The list includes any current actions that the group has scheduled for its instances. The orderBy query parameter is not supported. The `pageToken` query parameter is supported only in the alpha and beta API and only if the group's `listManagedInstancesResults` field is set to `PAGINATED`. """,
    tags=['compute_instance_groups_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_list_managed_instances(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/listPerInstanceConfigs',
    description=""" Lists all of the per-instance configurations defined for the managed instance group. The orderBy query parameter is not supported. """,
    tags=[
        'compute_instance_groups_management',
        'compute_resource_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_list_per_instance_configs(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/patchPerInstanceConfigs',
    description=""" Inserts or patches per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def patch_instance_group_manager_config(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupManagerPatchInstanceConfigReq = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/recreateInstances',
    description=""" Flags the specified VM instances in the managed instance group to be immediately recreated. Each instance is recreated using the group's current configuration. This operation is marked as DONE when the flag is set even if the instances have not yet been recreated. You must separately verify the status of each instance by checking its currentAction field; for more information, see Checking the status of managed instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_recreate_instances(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupManagersRecreateRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/resize',
    description=""" Changes the intended size of the managed instance group. If you increase the size, the group creates new instances using the current instance template. If you decrease the size, the group deletes one or more instances. The resize operation is marked DONE if the resize request is successful. The underlying actions take additional time. You must separately verify the status of the creating or deleting actions with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_resize(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    size: conint(ge=0) = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/setInstanceTemplate',
    description=""" Sets the instance template to use when creating new instances or recreating instances in this group. Existing instances are not affected. """,
    tags=['compute_instance_groups_management', 'compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_set_instance_template(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupManagersSetTemplateRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/setTargetPools',
    description=""" Modifies the target pools to which all new instances in this group are assigned. Existing instances in the group are not affected. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_group_managers_set_target_pools(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupManagersSetTargetPoolsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/updatePerInstanceConfigs',
    description=""" Inserts or updates per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch. """,
    tags=[
        'compute_instance_groups_management',
        'instance_configuration',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_instance_group_manager_configs(
    project: str,
    region: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupManagerUpdateInstanceConfigReq = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/instanceGroups',
    description=""" Retrieves the list of instance group resources contained within the specified region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_groups_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/instanceGroups/{instanceGroup}',
    description=""" Returns the specified instance group resource. """,
    tags=['compute_instance_groups_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_groups_get(
    project: str,
    region: str = ...,
    instance_group: str = Path(..., alias='instanceGroup'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroups/{instanceGroup}/listInstances',
    description=""" Lists the instances in the specified instance group and displays information about the named ports. Depending on the specified options, this method can list all instances or only the instances that are running. The orderBy query parameter is not supported. """,
    tags=['compute_instance_groups_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_groups_list_instances(
    project: str,
    region: str = ...,
    instance_group: str = Path(..., alias='instanceGroup'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupsListInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instanceGroups/{instanceGroup}/setNamedPorts',
    description=""" Sets the named ports for the specified regional instance group. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instance_groups_set_named_ports(
    project: str,
    region: str = ...,
    instance_group: str = Path(..., alias='instanceGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionInstanceGroupsSetNamedPortsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/instances/bulkInsert',
    description=""" Creates multiple instances in a given region. Count specifies the number of instances to create. """,
    tags=[
        'project_management_operations',
        'compute_instance_management',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_instances_bulk_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BulkInsertInstanceResource = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/interconnectAttachments',
    description=""" Retrieves the list of interconnect attachments contained within the specified region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnect_attachments_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/interconnectAttachments',
    description=""" Creates an InterconnectAttachment in the specified project using the data included in the request. """,
    tags=['compute_interconnect_operations', 'compute_network_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnect_attachments_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    validate_only: Optional[bool] = Query(None, alias='validateOnly'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InterconnectAttachment = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/interconnectAttachments/{interconnectAttachment}',
    description=""" Deletes the specified interconnect attachment. """,
    tags=[
        'compute_interconnect_operations',
        'compute_network_operations',
        'global_operations_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnect_attachments_delete(
    project: str,
    region: str = ...,
    interconnect_attachment: str = Path(..., alias='interconnectAttachment'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/interconnectAttachments/{interconnectAttachment}',
    description=""" Returns the specified interconnect attachment. """,
    tags=[
        'global_operations_management',
        'project_management_operations',
        'project_retrieval',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnect_attachments_get(
    project: str,
    region: str = ...,
    interconnect_attachment: str = Path(..., alias='interconnectAttachment'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/interconnectAttachments/{interconnectAttachment}',
    description=""" Updates the specified interconnect attachment with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=['compute_interconnect_operations', 'compute_network_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnect_attachments_patch(
    project: str,
    region: str = ...,
    interconnect_attachment: str = Path(..., alias='interconnectAttachment'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InterconnectAttachment = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/interconnectAttachments/{resource}/setLabels',
    description=""" Sets the labels on an InterconnectAttachment. To learn more about labels, read the Labeling Resources documentation. """,
    tags=[
        'project_management_operations',
        'global_operations_management',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_interconnect_attachments_set_labels(
    project: str,
    region: str = ...,
    resource: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/networkAttachments',
    description=""" Lists the NetworkAttachments for a project in the given scope. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_attachments_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/networkAttachments',
    description=""" Creates a NetworkAttachment in the specified project in the given scope using the parameters that are included in the request. """,
    tags=[
        'project_management_operations',
        'compute_network_operations',
        'network_firewall_policy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_attachments_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworkAttachment = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/networkAttachments/{networkAttachment}',
    description=""" Deletes the specified NetworkAttachment in the given scope """,
    tags=['vpn_operations', 'network_management', 'compute_network_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_attachments_delete(
    project: str,
    region: str = ...,
    network_attachment: str = Path(..., alias='networkAttachment'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/networkAttachments/{networkAttachment}',
    description=""" Returns the specified NetworkAttachment resource in the given scope. """,
    tags=[
        'project_management_operations',
        'compute_security_management',
        'compute_network_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_attachments_get(
    project: str,
    region: str = ...,
    network_attachment: str = Path(..., alias='networkAttachment'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/networkAttachments/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations', 'global_operations_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_attachments_get_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/networkAttachments/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=[
        'project_management_operations',
        'resource_aggregated_lists',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_attachments_set_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/networkAttachments/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=[
        'project_management_operations',
        'resource_aggregated_lists',
        'compute_security_management',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_attachments_test_iam_permissions(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/networkEdgeSecurityServices',
    description=""" Creates a new service in the specified project using the data included in the request. """,
    tags=[
        'compute_network_operations',
        'network_firewall_policy_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_edge_security_services_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    validate_only: Optional[bool] = Query(None, alias='validateOnly'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworkEdgeSecurityService = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/networkEdgeSecurityServices/{networkEdgeSecurityService}',
    description=""" Deletes the specified service. """,
    tags=['compute_network_operations', 'network_firewall_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_edge_security_services_delete(
    project: str,
    region: str = ...,
    network_edge_security_service: str = Path(..., alias='networkEdgeSecurityService'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/networkEdgeSecurityServices/{networkEdgeSecurityService}',
    description=""" Gets a specified NetworkEdgeSecurityService. """,
    tags=['compute_security_management', 'compute_network_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_edge_security_services_get(
    project: str,
    region: str = ...,
    network_edge_security_service: str = Path(..., alias='networkEdgeSecurityService'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/networkEdgeSecurityServices/{networkEdgeSecurityService}',
    description=""" Patches the specified policy with the data included in the request. """,
    tags=['network_firewall_policy_management', 'compute_network_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_edge_security_services_patch(
    project: str,
    region: str = ...,
    network_edge_security_service: str = Path(..., alias='networkEdgeSecurityService'),
    paths: Optional[Paths] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworkEdgeSecurityService = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/networkEndpointGroups',
    description=""" Retrieves the list of regional network endpoint groups available to the specified project in the given region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_endpoint_groups_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/networkEndpointGroups',
    description=""" Creates a network endpoint group in the specified project using the parameters that are included in the request. """,
    tags=['network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_endpoint_groups_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworkEndpointGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}',
    description=""" Deletes the specified network endpoint group. Note that the NEG cannot be deleted if it is configured as a backend of a backend service. """,
    tags=['network_endpoint_management', 'network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_endpoint_groups_delete(
    project: str,
    region: str = ...,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}',
    description=""" Returns the specified network endpoint group. """,
    tags=['network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_network_endpoint_groups_get(
    project: str,
    region: str = ...,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/nodeTemplates',
    description=""" Retrieves a list of node templates available to the specified project. """,
    tags=[
        'project_management_operations',
        'global_operations_management',
        'project_retrieval',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_templates_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/nodeTemplates',
    description=""" Creates a NodeTemplate resource in the specified project using the data included in the request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_templates_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NodeTemplate = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/nodeTemplates/{nodeTemplate}',
    description=""" Deletes the specified NodeTemplate resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_templates_delete(
    project: str,
    region: str = ...,
    node_template: str = Path(..., alias='nodeTemplate'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/nodeTemplates/{nodeTemplate}',
    description=""" Returns the specified node template. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_templates_get(
    project: str,
    region: str = ...,
    node_template: str = Path(..., alias='nodeTemplate'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/nodeTemplates/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_templates_get_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/nodeTemplates/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=[
        'region_set_policy_management',
        'resource_aggregated_lists',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_templates_set_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/nodeTemplates/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=[
        'firewall_policy_management',
        'firewall_policy_iam_management',
        'firewall_rule_management',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_templates_test_iam_permissions(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/notificationEndpoints',
    description=""" Lists the NotificationEndpoints for a project in the given region. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_notification_endpoints_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/notificationEndpoints',
    description=""" Create a NotificationEndpoint in the specified project in the given region using the parameters that are included in the request. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_notification_endpoints_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NotificationEndpoint = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/notificationEndpoints/{notificationEndpoint}',
    description=""" Deletes the specified NotificationEndpoint in the given region """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_notification_endpoints_delete(
    project: str,
    region: str = ...,
    notification_endpoint: str = Path(..., alias='notificationEndpoint'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/notificationEndpoints/{notificationEndpoint}',
    description=""" Returns the specified NotificationEndpoint resource in the given region. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_notification_endpoints_get(
    project: str,
    region: str = ...,
    notification_endpoint: str = Path(..., alias='notificationEndpoint'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/operations',
    description=""" Retrieves a list of Operation resources contained within the specified region. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_operations_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/operations/{operation}',
    description=""" Deletes the specified region-specific Operations resource. """,
    tags=['project_management_operations', 'global_operations_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_operations_delete(
    project: str,
    region: str = ...,
    operation: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/operations/{operation}',
    description=""" Retrieves the specified region-specific Operations resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_operations_get(
    project: str,
    region: str = ...,
    operation: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/operations/{operation}/wait',
    description=""" Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method differs from the `GET` method in that it waits for no more than the default deadline (2 minutes) and then returns the current state of the operation, which might be `DONE` or still in progress. This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.  """,
    tags=[
        'project_management_operations',
        'global_operations_management',
        'project_retrieval',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_operations_wait(
    project: str,
    region: str = ...,
    operation: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/packetMirrorings',
    description=""" Retrieves a list of PacketMirroring resources available to the specified project and region. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_packet_mirrorings_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/packetMirrorings',
    description=""" Creates a PacketMirroring resource in the specified project and region using the data included in the request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_packet_mirrorings_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: PacketMirroring = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}',
    description=""" Deletes the specified PacketMirroring resource. """,
    tags=['project_metadata_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_packet_mirrorings_delete(
    project: str,
    region: str = ...,
    packet_mirroring: str = Path(..., alias='packetMirroring'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}',
    description=""" Returns the specified PacketMirroring resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_packet_mirrorings_get(
    project: str,
    region: str = ...,
    packet_mirroring: str = Path(..., alias='packetMirroring'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}',
    description=""" Patches the specified PacketMirroring resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=['network_firewall_policy_management', 'firewall_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_packet_mirrorings_patch(
    project: str,
    region: str = ...,
    packet_mirroring: str = Path(..., alias='packetMirroring'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: PacketMirroring = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/packetMirrorings/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_packet_mirrorings_test_iam_permissions(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/publicDelegatedPrefixes',
    description=""" Lists the PublicDelegatedPrefixes for a project in the given region. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_delegated_prefixes_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/publicDelegatedPrefixes',
    description=""" Creates a PublicDelegatedPrefix in the specified project in the given region using the parameters that are included in the request. """,
    tags=['project_management_operations', 'public_delegated_prefix_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_delegated_prefixes_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: PublicDelegatedPrefix = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/publicDelegatedPrefixes/{publicDelegatedPrefix}',
    description=""" Deletes the specified PublicDelegatedPrefix in the given region. """,
    tags=['public_delegated_prefix_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_delegated_prefixes_delete(
    project: str,
    region: str = ...,
    public_delegated_prefix: str = Path(..., alias='publicDelegatedPrefix'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/publicDelegatedPrefixes/{publicDelegatedPrefix}',
    description=""" Returns the specified PublicDelegatedPrefix resource in the given region. """,
    tags=['public_delegated_prefix_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_delegated_prefixes_get(
    project: str,
    region: str = ...,
    public_delegated_prefix: str = Path(..., alias='publicDelegatedPrefix'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/publicDelegatedPrefixes/{publicDelegatedPrefix}',
    description=""" Patches the specified PublicDelegatedPrefix resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=['public_delegated_prefix_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_public_delegated_prefixes_patch(
    project: str,
    region: str = ...,
    public_delegated_prefix: str = Path(..., alias='publicDelegatedPrefix'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: PublicDelegatedPrefix = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/resourcePolicies',
    description=""" A list all the resource policies that have been configured for the specified project in specified region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_resource_policies_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/resourcePolicies',
    description=""" Creates a new resource policy. """,
    tags=['project_management_operations', 'global_operations_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_resource_policies_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ResourcePolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}',
    description=""" Deletes the specified resource policy. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_resource_policies_delete(
    project: str,
    region: str = ...,
    resource_policy: str = Path(..., alias='resourcePolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}',
    description=""" Retrieves all information of the specified resource policy. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_resource_policies_get(
    project: str,
    region: str = ...,
    resource_policy: str = Path(..., alias='resourcePolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/resourcePolicies/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_resource_policies_get_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/resourcePolicies/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['project_management_operations', 'firewall_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_resource_policies_set_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/resourcePolicies/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_resource_policies_test_iam_permissions(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/routers',
    description=""" Retrieves a list of Router resources available to the specified project. """,
    tags=[
        'project_retrieval',
        'global_operations_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routers_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/routers',
    description=""" Creates a Router resource in the specified project and region using the data included in the request. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routers_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Router = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/routers/{router}',
    description=""" Deletes the specified Router resource. """,
    tags=[
        'project_management_operations',
        'compute_resource_management',
        'network_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routers_delete(
    project: str,
    region: str = ...,
    router: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/routers/{router}',
    description=""" Returns the specified Router resource. """,
    tags=[
        'project_retrieval',
        'project_management_operations',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routers_get(
    project: str,
    region: str = ...,
    router: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/routers/{router}',
    description=""" Patches the specified Router resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=['compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routers_patch(
    project: str,
    region: str = ...,
    router: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Router = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/regions/{region}/routers/{router}',
    description=""" Updates the specified Router resource with the data included in the request. This method conforms to PUT semantics, which requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload. """,
    tags=['compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routers_update(
    project: str,
    region: str = ...,
    router: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Router = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/routers/{router}/getNatMappingInfo',
    description=""" Retrieves runtime Nat mapping information of VM endpoints. """,
    tags=[
        'resource_aggregated_lists',
        'compute_resource_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routers_get_nat_mapping_info(
    project: str,
    region: str = ...,
    router: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    nat_name: Optional[str] = Query(None, alias='natName'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/routers/{router}/getRouterStatus',
    description=""" Retrieves runtime information of the specified router. """,
    tags=['compute_resource_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routers_get_router_status(
    project: str,
    region: str = ...,
    router: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/routers/{router}/preview',
    description=""" Preview fields auto-generated during router create and update operations. Calling this method does NOT create or update the router. """,
    tags=['compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_routers_preview(
    project: str,
    region: str = ...,
    router: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Router = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/securityPolicies',
    description=""" List all the policies that have been configured for the specified project and region. """,
    tags=[
        'project_retrieval',
        'global_operations_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_security_policies_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/securityPolicies',
    description=""" Creates a new policy in the specified project using the data included in the request. """,
    tags=['firewall_policy_management', 'security_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_security_policies_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    validate_only: Optional[bool] = Query(None, alias='validateOnly'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SecurityPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/securityPolicies/{securityPolicy}',
    description=""" Deletes the specified policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_security_policies_delete(
    project: str,
    region: str = ...,
    security_policy: str = Path(..., alias='securityPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/securityPolicies/{securityPolicy}',
    description=""" List all of the ordered rules present in a single specified policy. """,
    tags=[
        'firewall_policy_management',
        'network_firewall_policy_management',
        'security_policy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_security_policies_get(
    project: str,
    region: str = ...,
    security_policy: str = Path(..., alias='securityPolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/securityPolicies/{securityPolicy}',
    description=""" Patches the specified policy with the data included in the request. To clear fields in the rule, leave the fields empty and specify them in the updateMask. This cannot be used to be update the rules in the policy. Please use the per rule methods like addRule, patchRule, and removeRule instead. """,
    tags=[
        'firewall_policy_management',
        'compute_security_management',
        'security_policy_management',
        'backend_security_policy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_security_policies_patch(
    project: str,
    region: str = ...,
    security_policy: str = Path(..., alias='securityPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SecurityPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/serviceAttachments',
    description=""" Lists the ServiceAttachments for a project in the given scope. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_service_attachments_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/serviceAttachments',
    description=""" Creates a ServiceAttachment in the specified project in the given scope using the parameters that are included in the request. """,
    tags=[
        'project_management_operations',
        'resource_aggregated_lists',
        'compute_network_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_service_attachments_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ServiceAttachment = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/serviceAttachments/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_service_attachments_get_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/serviceAttachments/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=[
        'project_management_operations',
        'resource_aggregated_lists',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_service_attachments_set_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/serviceAttachments/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=[
        'firewall_policy_management',
        'project_management_operations',
        'firewall_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_service_attachments_test_iam_permissions(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}',
    description=""" Deletes the specified ServiceAttachment in the given scope """,
    tags=['project_management_operations', 'service_attachment_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_service_attachments_delete(
    project: str,
    region: str = ...,
    service_attachment: str = Path(..., alias='serviceAttachment'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}',
    description=""" Returns the specified ServiceAttachment resource in the given scope. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_service_attachments_get(
    project: str,
    region: str = ...,
    service_attachment: str = Path(..., alias='serviceAttachment'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}',
    description=""" Patches the specified ServiceAttachment resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=[
        'compute_network_operations',
        'network_firewall_policy_management',
        'target_proxy_operations',
        'backend_service_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_service_attachments_patch(
    project: str,
    region: str = ...,
    service_attachment: str = Path(..., alias='serviceAttachment'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ServiceAttachment = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/sslCertificates',
    description=""" Retrieves the list of SslCertificate resources available to the specified project in the specified region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_ssl_certificates_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/sslCertificates',
    description=""" Creates a SslCertificate resource in the specified project and region using the data included in the request """,
    tags=['ssl_certificate_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_ssl_certificates_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SslCertificate = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/sslCertificates/{sslCertificate}',
    description=""" Deletes the specified SslCertificate resource in the region. """,
    tags=['ssl_certificate_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_ssl_certificates_delete(
    project: str,
    region: str = ...,
    ssl_certificate: str = Path(..., alias='sslCertificate'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/sslCertificates/{sslCertificate}',
    description=""" Returns the specified SslCertificate resource in the specified region. Get a list of available SSL certificates by making a list() request. """,
    tags=['ssl_certificate_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_ssl_certificates_get(
    project: str,
    region: str = ...,
    ssl_certificate: str = Path(..., alias='sslCertificate'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/sslPolicies',
    description=""" Lists all the SSL policies that have been configured for the specified project and region. """,
    tags=[
        'project_retrieval',
        'global_operations_management',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_ssl_policies_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/sslPolicies',
    description=""" Creates a new policy in the specified project and region using the data included in the request. """,
    tags=['ssl_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_ssl_policies_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SslPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/sslPolicies/listAvailableFeatures',
    description=""" Lists all features that can be specified in the SSL policy when using custom profile. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_ssl_policies_list_available_features(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/sslPolicies/{sslPolicy}',
    description=""" Deletes the specified SSL policy. The SSL policy resource can be deleted only if it is not in use by any TargetHttpsProxy or TargetSslProxy resources. """,
    tags=['ssl_policy_management', 'firewall_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_ssl_policies_delete(
    project: str,
    region: str = ...,
    ssl_policy: str = Path(..., alias='sslPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/sslPolicies/{sslPolicy}',
    description=""" Lists all of the ordered rules present in a single specified policy. """,
    tags=['ssl_policy_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_ssl_policies_get(
    project: str,
    region: str = ...,
    ssl_policy: str = Path(..., alias='sslPolicy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/sslPolicies/{sslPolicy}',
    description=""" Patches the specified SSL policy with the data included in the request. """,
    tags=['ssl_policy_management', 'compute_security_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_ssl_policies_patch(
    project: str,
    region: str = ...,
    ssl_policy: str = Path(..., alias='sslPolicy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SslPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/subnetworks',
    description=""" Retrieves a list of subnetworks available to the specified project. """,
    tags=['project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/subnetworks',
    description=""" Creates a subnetwork in the specified project using the data included in the request. """,
    tags=['subnetwork_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Subnetwork = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/subnetworks/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_get_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/subnetworks/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=[
        'project_management_operations',
        'resource_aggregated_lists',
        'project_retrieval',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_set_iam_policy(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/subnetworks/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=[
        'firewall_policy_management',
        'firewall_management',
        'firewall_rule_management',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_test_iam_permissions(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/subnetworks/{subnetwork}',
    description=""" Deletes the specified subnetwork. """,
    tags=[
        'project_management_operations',
        'subnetwork_operations',
        'compute_network_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_delete(
    project: str,
    region: str = ...,
    subnetwork: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/subnetworks/{subnetwork}',
    description=""" Returns the specified subnetwork. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_get(
    project: str,
    region: str = ...,
    subnetwork: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/subnetworks/{subnetwork}',
    description=""" Patches the specified subnetwork with the data included in the request. Only certain fields can be updated with a patch request as indicated in the field descriptions. You must specify the current fingerprint of the subnetwork resource being patched. """,
    tags=['subnetwork_operations', 'compute_network_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_patch(
    project: str,
    region: str = ...,
    subnetwork: str = ...,
    drain_timeout_seconds: Optional[int] = Query(None, alias='drainTimeoutSeconds'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Subnetwork = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/subnetworks/{subnetwork}/expandIpCidrRange',
    description=""" Expands the IP CIDR range of the subnetwork to a specified value. """,
    tags=['subnetwork_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_expand_ip_cidr_range(
    project: str,
    region: str = ...,
    subnetwork: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SubnetworksExpandIpCidrRangeRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/subnetworks/{subnetwork}/setPrivateIpGoogleAccess',
    description=""" Set whether VMs in this subnet can access Google services without assigning external IP addresses through Private Google Access. """,
    tags=['subnetwork_operations', 'compute_network_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_subnetworks_set_private_ip_google_access(
    project: str,
    region: str = ...,
    subnetwork: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SubnetworksSetPrivateIpGoogleAccessRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/targetHttpProxies',
    description=""" Retrieves the list of TargetHttpProxy resources available to the specified project in the specified region. """,
    tags=[
        'project_retrieval',
        'global_operations_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_http_proxies_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetHttpProxies',
    description=""" Creates a TargetHttpProxy resource in the specified project and region using the data included in the request. """,
    tags=['target_proxy_operations', 'backend_service_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_http_proxies_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetHttpProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/targetHttpProxies/{targetHttpProxy}',
    description=""" Deletes the specified TargetHttpProxy resource. """,
    tags=['target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_http_proxies_delete(
    project: str,
    region: str = ...,
    target_http_proxy: str = Path(..., alias='targetHttpProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/targetHttpProxies/{targetHttpProxy}',
    description=""" Returns the specified TargetHttpProxy resource in the specified region. """,
    tags=['target_proxy_operations', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_http_proxies_get(
    project: str,
    region: str = ...,
    target_http_proxy: str = Path(..., alias='targetHttpProxy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetHttpProxies/{targetHttpProxy}/setUrlMap',
    description=""" Changes the URL map for TargetHttpProxy. """,
    tags=['target_proxy_operations', 'http_proxy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_http_proxies_set_url_map(
    project: str,
    region: str = ...,
    target_http_proxy: str = Path(..., alias='targetHttpProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMapReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/targetHttpsProxies',
    description=""" Retrieves the list of TargetHttpsProxy resources available to the specified project in the specified region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_https_proxies_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetHttpsProxies',
    description=""" Creates a TargetHttpsProxy resource in the specified project and region using the data included in the request. """,
    tags=['project_management_operations', 'target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_https_proxies_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetHttpsProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/targetHttpsProxies/{targetHttpsProxy}',
    description=""" Deletes the specified TargetHttpsProxy resource. """,
    tags=[
        'target_https_proxy_operations',
        'http_proxy_management',
        'https_proxy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_https_proxies_delete(
    project: str,
    region: str = ...,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/targetHttpsProxies/{targetHttpsProxy}',
    description=""" Returns the specified TargetHttpsProxy resource in the specified region. """,
    tags=['target_proxy_operations', 'http_proxy_management', 'https_proxy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_https_proxies_get(
    project: str,
    region: str = ...,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/targetHttpsProxies/{targetHttpsProxy}',
    description=""" Patches the specified regional TargetHttpsProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=['target_proxy_operations', 'http_proxy_management', 'https_proxy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_https_proxies_patch(
    project: str,
    region: str = ...,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetHttpsProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates',
    description=""" Replaces SslCertificates for TargetHttpsProxy. """,
    tags=['ssl_certificate_management', 'https_proxy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_https_proxies_set_ssl_certificates(
    project: str,
    region: str = ...,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionTargetHttpsProxiesSetSslCertificatesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetHttpsProxies/{targetHttpsProxy}/setUrlMap',
    description=""" Changes the URL map for TargetHttpsProxy. """,
    tags=['target_proxy_operations', 'http_proxy_management', 'https_proxy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_https_proxies_set_url_map(
    project: str,
    region: str = ...,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMapReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/targetPools',
    description=""" Retrieves a list of target pools available to the specified project and region. """,
    tags=[
        'project_retrieval',
        'global_operations_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetPools',
    description=""" Creates a target pool in the specified project and region using the data included in the request. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_resource_management',
        'target_pool_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetPool = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/targetPools/{targetPool}',
    description=""" Deletes the specified target pool. """,
    tags=['target_pool_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_delete(
    project: str,
    region: str = ...,
    target_pool: str = Path(..., alias='targetPool'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/targetPools/{targetPool}',
    description=""" Returns the specified target pool. """,
    tags=[
        'target_pool_management',
        'project_management_operations',
        'global_operations_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_get(
    project: str,
    region: str = ...,
    target_pool: str = Path(..., alias='targetPool'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetPools/{targetPool}/addHealthCheck',
    description=""" Adds health check URLs to a target pool. """,
    tags=['target_pool_management', 'compute_health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_add_health_check(
    project: str,
    region: str = ...,
    target_pool: str = Path(..., alias='targetPool'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetPoolsAddHealthCheckRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetPools/{targetPool}/addInstance',
    description=""" Adds an instance to a target pool. """,
    tags=['target_pool_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_add_instance(
    project: str,
    region: str = ...,
    target_pool: str = Path(..., alias='targetPool'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetPoolsAddInstanceRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetPools/{targetPool}/getHealth',
    description=""" Gets the most recent health check results for each IP for the instance that is referenced by the given target pool. """,
    tags=[
        'compute_instance_groups_management',
        'target_pool_management',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_get_health(
    project: str,
    region: str = ...,
    target_pool: str = Path(..., alias='targetPool'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetPools/{targetPool}/removeHealthCheck',
    description=""" Removes health check URL from a target pool. """,
    tags=['target_pool_management', 'compute_health_checks_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_remove_health_check(
    project: str,
    region: str = ...,
    target_pool: str = Path(..., alias='targetPool'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetPoolsRemoveHealthCheckRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetPools/{targetPool}/removeInstance',
    description=""" Removes instance URL from a target pool. """,
    tags=['target_pool_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_remove_instance(
    project: str,
    region: str = ...,
    target_pool: str = Path(..., alias='targetPool'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetPoolsRemoveInstanceRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetPools/{targetPool}/setBackup',
    description=""" Changes a backup target pool's configurations. """,
    tags=['target_pool_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_pools_set_backup(
    project: str,
    region: str = ...,
    target_pool: str = Path(..., alias='targetPool'),
    failover_ratio: Optional[float] = Query(None, alias='failoverRatio'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/targetTcpProxies',
    description=""" Retrieves a list of TargetTcpProxy resources available to the specified project in a given region. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_tcp_proxies_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetTcpProxies',
    description=""" Creates a TargetTcpProxy resource in the specified project and region using the data included in the request. """,
    tags=['target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_tcp_proxies_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetTcpProxy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/targetTcpProxies/{targetTcpProxy}',
    description=""" Deletes the specified TargetTcpProxy resource. """,
    tags=['target_proxy_operations', 'tcp_proxy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_tcp_proxies_delete(
    project: str,
    region: str = ...,
    target_tcp_proxy: str = Path(..., alias='targetTcpProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/targetTcpProxies/{targetTcpProxy}',
    description=""" Returns the specified TargetTcpProxy resource. """,
    tags=['target_proxy_operations', 'tcp_proxy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_target_tcp_proxies_get(
    project: str,
    region: str = ...,
    target_tcp_proxy: str = Path(..., alias='targetTcpProxy'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/targetVpnGateways',
    description=""" Retrieves a list of target VPN gateways available to the specified project and region. """,
    tags=['project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_vpn_gateways_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetVpnGateways',
    description=""" Creates a target VPN gateway in the specified project and region using the data included in the request. """,
    tags=[
        'vpn_operations',
        'project_management_operations',
        'resource_aggregated_lists',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_vpn_gateways_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetVpnGateway = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/targetVpnGateways/{resource}/setLabels',
    description=""" Sets the labels on a TargetVpnGateway. To learn more about labels, read the Labeling Resources documentation. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_vpn_gateways_set_labels(
    project: str,
    region: str = ...,
    resource: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/targetVpnGateways/{targetVpnGateway}',
    description=""" Deletes the specified target VPN gateway. """,
    tags=['vpn_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_vpn_gateways_delete(
    project: str,
    region: str = ...,
    target_vpn_gateway: str = Path(..., alias='targetVpnGateway'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/targetVpnGateways/{targetVpnGateway}',
    description=""" Returns the specified target VPN gateway. """,
    tags=['vpn_operations', 'external_vpn_gateway_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_vpn_gateways_get(
    project: str,
    region: str = ...,
    target_vpn_gateway: str = Path(..., alias='targetVpnGateway'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/urlMaps',
    description=""" Retrieves the list of UrlMap resources available to the specified project in the specified region. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_url_maps_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/urlMaps',
    description=""" Creates a UrlMap resource in the specified project using the data included in the request. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_url_maps_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMap = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/urlMaps/{urlMap}',
    description=""" Deletes the specified UrlMap resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_url_maps_delete(
    project: str,
    region: str = ...,
    url_map: str = Path(..., alias='urlMap'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/urlMaps/{urlMap}',
    description=""" Returns the specified UrlMap resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_url_maps_get(
    project: str,
    region: str = ...,
    url_map: str = Path(..., alias='urlMap'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/regions/{region}/urlMaps/{urlMap}',
    description=""" Patches the specified UrlMap resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. """,
    tags=[
        'resource_aggregated_lists',
        'compute_network_operations',
        'target_proxy_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_url_maps_patch(
    project: str,
    region: str = ...,
    url_map: str = Path(..., alias='urlMap'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMap = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/regions/{region}/urlMaps/{urlMap}',
    description=""" Updates the specified UrlMap resource with the data included in the request. """,
    tags=[
        'backend_service_management',
        'global_operations_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_url_maps_update(
    project: str,
    region: str = ...,
    url_map: str = Path(..., alias='urlMap'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMap = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/urlMaps/{urlMap}/validate',
    description=""" Runs static validation for the UrlMap. In particular, the tests of the provided UrlMap will be run. Calling this method does NOT create the UrlMap. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_region_url_maps_validate(
    project: str,
    region: str = ...,
    url_map: str = Path(..., alias='urlMap'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionUrlMapsValidateRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/vpnGateways',
    description=""" Retrieves a list of VPN gateways available to the specified project and region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_gateways_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/vpnGateways',
    description=""" Creates a VPN gateway in the specified project and region using the data included in the request. """,
    tags=['vpn_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_gateways_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: VpnGateway = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/vpnGateways/{resource}/setLabels',
    description=""" Sets the labels on a VpnGateway. To learn more about labels, read the Labeling Resources documentation. """,
    tags=['project_management_operations', 'resource_aggregated_lists'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_gateways_set_labels(
    project: str,
    region: str = ...,
    resource: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/vpnGateways/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_gateways_test_iam_permissions(
    project: str,
    region: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/vpnGateways/{vpnGateway}',
    description=""" Deletes the specified VPN gateway. """,
    tags=['vpn_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_gateways_delete(
    project: str,
    region: str = ...,
    vpn_gateway: str = Path(..., alias='vpnGateway'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/vpnGateways/{vpnGateway}',
    description=""" Returns the specified VPN gateway. """,
    tags=['vpn_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_gateways_get(
    project: str,
    region: str = ...,
    vpn_gateway: str = Path(..., alias='vpnGateway'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/vpnGateways/{vpnGateway}/getStatus',
    description=""" Returns the status for the specified VPN gateway. """,
    tags=['vpn_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_gateways_get_status(
    project: str,
    region: str = ...,
    vpn_gateway: str = Path(..., alias='vpnGateway'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/vpnTunnels',
    description=""" Retrieves a list of VpnTunnel resources contained in the specified project and region. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_tunnels_list(
    project: str,
    region: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/vpnTunnels',
    description=""" Creates a VpnTunnel resource in the specified project and region using the data included in the request. """,
    tags=['vpn_operations', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_tunnels_insert(
    project: str,
    region: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: VpnTunnel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/regions/{region}/vpnTunnels/{resource}/setLabels',
    description=""" Sets the labels on a VpnTunnel. To learn more about labels, read the Labeling Resources documentation. """,
    tags=[
        'project_management_operations',
        'resource_aggregated_lists',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_tunnels_set_labels(
    project: str,
    region: str = ...,
    resource: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: RegionSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/regions/{region}/vpnTunnels/{vpnTunnel}',
    description=""" Deletes the specified VpnTunnel resource. """,
    tags=['vpn_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_tunnels_delete(
    project: str,
    region: str = ...,
    vpn_tunnel: str = Path(..., alias='vpnTunnel'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/regions/{region}/vpnTunnels/{vpnTunnel}',
    description=""" Returns the specified VpnTunnel resource. """,
    tags=['vpn_operations', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_vpn_tunnels_get(
    project: str,
    region: str = ...,
    vpn_tunnel: str = Path(..., alias='vpnTunnel'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/setCommonInstanceMetadata',
    description=""" Sets metadata common to all instances within the specified project using the data included in the request. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'project_metadata_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_set_common_instance_metadata(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Metadata = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/setDefaultNetworkTier',
    description=""" Sets the default network tier of the project. The default network tier is used when an address/forwardingRule/instance is created without specifying the network tier field. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_set_default_network_tier(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ProjectsSetDefaultNetworkTierRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/setUsageExportBucket',
    description=""" Enables the usage export feature and sets the usage export bucket where reports are stored. If you provide an empty request body using this method, the usage export feature will be disabled. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_projects_set_usage_export_bucket(
    project: str,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UsageExportLocation = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/targetHttpProxies/{targetHttpProxy}/setUrlMap',
    description=""" Changes the URL map for TargetHttpProxy. """,
    tags=['http_proxy_management', 'tcp_proxy_management', 'target_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_http_proxies_set_url_map(
    project: str,
    target_http_proxy: str = Path(..., alias='targetHttpProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMapReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates',
    description=""" Replaces SslCertificates for TargetHttpsProxy. """,
    tags=[
        'ssl_certificate_management',
        'https_proxy_management',
        'target_proxy_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_set_ssl_certificates(
    project: str,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetHttpsProxiesSetSslCertificatesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setUrlMap',
    description=""" Changes the URL map for TargetHttpsProxy. """,
    tags=['target_https_proxy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_https_proxies_set_url_map(
    project: str,
    target_https_proxy: str = Path(..., alias='targetHttpsProxy'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: UrlMapReference = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones',
    description=""" Retrieves the list of Zone resources available to the specified project. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'resource_aggregated_lists',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_zones_list(
    project: str,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}',
    description=""" Returns the specified Zone resource. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_zones_get(
    project: str,
    zone: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/acceleratorTypes',
    description=""" Retrieves a list of accelerator types that are available to the specified project. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'global_operations_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_accelerator_types_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/acceleratorTypes/{acceleratorType}',
    description=""" Returns the specified accelerator type. """,
    tags=[
        'resource_aggregated_lists',
        'accelerator_type_management',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_accelerator_types_get(
    project: str,
    zone: str = ...,
    accelerator_type: str = Path(..., alias='acceleratorType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/autoscalers',
    description=""" Retrieves a list of autoscalers contained within the specified zone. """,
    tags=[
        'project_retrieval',
        'global_operations_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_autoscalers_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/zones/{zone}/autoscalers',
    description=""" Updates an autoscaler in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=[
        'resource_aggregated_lists',
        'compute_instance_management',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_autoscalers_patch(
    project: str,
    zone: str = ...,
    autoscaler: Optional[str] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Autoscaler = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/autoscalers',
    description=""" Creates an autoscaler in the specified project using the data included in the request. """,
    tags=[
        'project_management_operations',
        'compute_resource_management',
        'resource_aggregated_lists',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_autoscalers_insert(
    project: str,
    zone: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Autoscaler = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/zones/{zone}/autoscalers',
    description=""" Updates an autoscaler in the specified project using the data included in the request. """,
    tags=['resource_aggregated_lists', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_autoscalers_update(
    project: str,
    zone: str = ...,
    autoscaler: Optional[str] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Autoscaler = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/zones/{zone}/autoscalers/{autoscaler}',
    description=""" Deletes the specified autoscaler. """,
    tags=['project_management_operations', 'compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_autoscalers_delete(
    project: str,
    zone: str = ...,
    autoscaler: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/autoscalers/{autoscaler}',
    description=""" Returns the specified autoscaler resource. """,
    tags=['project_management_operations', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_autoscalers_get(
    project: str,
    zone: str = ...,
    autoscaler: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/diskTypes',
    description=""" Retrieves a list of disk types available to the specified project. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'global_operations_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disk_types_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/diskTypes/{diskType}',
    description=""" Returns the specified disk type. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disk_types_get(
    project: str,
    zone: str = ...,
    disk_type: str = Path(..., alias='diskType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/disks',
    description=""" Retrieves a list of persistent disks contained within the specified zone. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/disks',
    description=""" Creates a persistent disk in the specified project using the data in the request. You can create a disk from a source (sourceImage, sourceSnapshot, or sourceDisk) or create an empty 500 GB data disk by omitting all properties. You can also create a disk that is larger than the default size by specifying the sizeGb property. """,
    tags=['compute_image_management', 'disk_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_insert(
    project: str,
    zone: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    source_image: Optional[str] = Query(None, alias='sourceImage'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Disk = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/zones/{zone}/disks/{disk}',
    description=""" Deletes the specified persistent disk. Deleting a disk removes its data permanently and is irreversible. However, deleting a disk does not delete any snapshots previously made from the disk. You must separately delete snapshots. """,
    tags=['disk_management', 'zone_management', 'instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_delete(
    project: str,
    zone: str = ...,
    disk: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/disks/{disk}',
    description=""" Returns the specified persistent disk. """,
    tags=['disk_management', 'zone_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_get(
    project: str,
    zone: str = ...,
    disk: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/zones/{zone}/disks/{disk}',
    description=""" Updates the specified disk with the data included in the request. The update is performed only on selected fields included as part of update-mask. Only the following fields can be modified: user_license. """,
    tags=['disk_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_update(
    project: str,
    zone: str = ...,
    disk: str = ...,
    paths: Optional[Paths] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Disk = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/disks/{disk}/addResourcePolicies',
    description=""" Adds existing resource policies to a disk. You can only add one policy which will be applied to this disk for scheduling snapshot creation. """,
    tags=['disk_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_add_resource_policies(
    project: str,
    zone: str = ...,
    disk: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: DisksAddResourcePoliciesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/disks/{disk}/createSnapshot',
    description=""" Creates a snapshot of a specified persistent disk. For regular snapshot creation, consider using snapshots.insert instead, as that method supports more features, such as creating snapshots in a project different from the source disk project. """,
    tags=['snapshot_management', 'disk_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_create_snapshot(
    project: str,
    zone: str = ...,
    disk: str = ...,
    guest_flush: Optional[bool] = Query(None, alias='guestFlush'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Snapshot = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/disks/{disk}/removeResourcePolicies',
    description=""" Removes resource policies from a disk. """,
    tags=['disk_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_remove_resource_policies(
    project: str,
    zone: str = ...,
    disk: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: DisksRemoveResourcePoliciesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/disks/{disk}/resize',
    description=""" Resizes the specified persistent disk. You can only increase the size of the disk. """,
    tags=['disk_management', 'zone_management', 'instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_resize(
    project: str,
    zone: str = ...,
    disk: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: DisksResizeRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/disks/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_get_iam_policy(
    project: str,
    zone: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/disks/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['zone_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_set_iam_policy(
    project: str,
    zone: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ZoneSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/disks/{resource}/setLabels',
    description=""" Sets the labels on a disk. To learn more about labels, read the Labeling Resources documentation. """,
    tags=['project_management_operations', 'zone_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_set_labels(
    project: str,
    zone: str = ...,
    resource: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ZoneSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/disks/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['firewall_policy_iam_management', 'firewall_policy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_disks_test_iam_permissions(
    project: str,
    zone: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/imageFamilyViews/{family}',
    description=""" Returns the latest image that is part of an image family, is not deprecated and is rolled out in the specified zone. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_image_family_views_get(
    project: str,
    zone: str = ...,
    family: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instanceGroupManagers',
    description=""" Retrieves a list of managed instance groups that are contained within the specified project and zone. """,
    tags=[
        'project_management_operations',
        'global_operations_management',
        'project_retrieval',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers',
    description=""" Creates a managed instance group using the information that you specify in the request. After the group is created, instances in the group are created using the specified instance template. This operation is marked as DONE when the group is created even if the instances in the group have not yet been created. You must separately verify the status of the individual instances with the listmanagedinstances method. A managed instance group can have up to 1000 VM instances per group. Please contact Cloud Support if you need an increase in this limit. """,
    tags=['compute_instance_groups_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_insert(
    project: str,
    zone: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManager = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}',
    description=""" Deletes the specified managed instance group and all of the instances in that group. Note that the instance group must not belong to a backend service. Read Deleting an instance group for more information. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_delete(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}',
    description=""" Returns all of the details about the specified managed instance group. """,
    tags=['compute_instance_groups_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_get(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}',
    description=""" Updates a managed instance group using the information that you specify in the request. This operation is marked as DONE when the group is patched even if the instances in the group are still in the process of being patched. You must separately verify the status of the individual instances with the listManagedInstances method. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. If you update your group to specify a new template or instance configuration, it's possible that your intended specification for each VM in the group is different from the current state of that VM. To learn how to apply an updated configuration to the VMs in a MIG, see Updating instances in a MIG. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_patch(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManager = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/abandonInstances',
    description=""" Flags the specified instances to be removed from the managed instance group. Abandoning an instance does not delete the instance, but it does remove the instance from any target pools that are applied by the managed instance group. This method reduces the targetSize of the managed instance group by the number of instances that you abandon. This operation is marked as DONE when the action is scheduled even if the instances have not yet been removed from the group. You must separately verify the status of the abandoning action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request. """,
    tags=['compute_instance_groups_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_abandon_instances(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManagersAbandonInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances',
    description=""" Applies changes to selected instances on the managed instance group. This method can be used to apply new overrides and/or new versions. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_apply_updates_to_instances(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManagersApplyUpdatesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/createInstances',
    description=""" Creates instances with per-instance configurations in this managed instance group. Instances are created using the current instance template. The create instances operation is marked DONE if the createInstances request is successful. The underlying actions take additional time. You must separately verify the status of the creating or actions with the listmanagedinstances method. """,
    tags=['compute_instance_groups_management', 'instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_create_instances(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManagersCreateInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/deleteInstances',
    description=""" Flags the specified instances in the managed instance group for immediate deletion. The instances are also removed from any target pools of which they were a member. This method reduces the targetSize of the managed instance group by the number of instances that you delete. This operation is marked as DONE when the action is scheduled even if the instances are still being deleted. You must separately verify the status of the deleting action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request. """,
    tags=['compute_instance_groups_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_delete_instances(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManagersDeleteInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/deletePerInstanceConfigs',
    description=""" Deletes selected per-instance configurations for the managed instance group. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_delete_per_instance_configs(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManagersDeletePerInstanceConfigsReq = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/listErrors',
    description=""" Lists all errors thrown by actions on instances for a given managed instance group. The filter and orderBy query parameters are not supported. """,
    tags=['compute_instance_groups_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_list_errors(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/listManagedInstances',
    description=""" Lists all of the instances in the managed instance group. Each instance in the list has a currentAction, which indicates the action that the managed instance group is performing on the instance. For example, if the group is still creating an instance, the currentAction is CREATING. If a previous action failed, the list displays the errors for that failed action. The orderBy query parameter is not supported. The `pageToken` query parameter is supported only in the alpha and beta API and only if the group's `listManagedInstancesResults` field is set to `PAGINATED`. """,
    tags=[
        'compute_instance_groups_management',
        'compute_instance_management',
        'zone_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_list_managed_instances(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/listPerInstanceConfigs',
    description=""" Lists all of the per-instance configurations defined for the managed instance group. The orderBy query parameter is not supported. """,
    tags=['compute_instance_groups_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_list_per_instance_configs(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/patchPerInstanceConfigs',
    description=""" Inserts or patches per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch. """,
    tags=['compute_instance_groups_management', 'compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_patch_per_instance_configs(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManagersPatchPerInstanceConfigsReq = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/recreateInstances',
    description=""" Flags the specified VM instances in the managed instance group to be immediately recreated. Each instance is recreated using the group's current configuration. This operation is marked as DONE when the flag is set even if the instances have not yet been recreated. You must separately verify the status of each instance by checking its currentAction field; for more information, see Checking the status of managed instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_recreate_instances(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManagersRecreateInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/resize',
    description=""" Resizes the managed instance group. If you increase the size, the group creates new instances using the current instance template. If you decrease the size, the group deletes instances. The resize operation is marked DONE when the resize actions are scheduled even if the group has not yet added or deleted any instances. You must separately verify the status of the creating or deleting actions with the listmanagedinstances method. When resizing down, the instance group arbitrarily chooses the order in which VMs are deleted. The group takes into account some VM attributes when making the selection including: + The status of the VM instance. + The health of the VM instance. + The instance template version the VM is based on. + For regional managed instance groups, the location of the VM instance. This list is subject to change. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. """,
    tags=['compute_instance_groups_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_resize(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    size: int = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setInstanceTemplate',
    description=""" Specifies the instance template to use when creating new instances in this group. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group's updatePolicy.type to PROACTIVE. """,
    tags=[
        'compute_instance_groups_management',
        'compute_instance_management',
        'instance_management',
        'instance_configuration',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_set_instance_template(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManagersSetInstanceTemplateRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools',
    description=""" Modifies the target pools to which all instances in this managed instance group are assigned. The target pools automatically apply to all of the instances in the managed instance group. This operation is marked DONE when you make the request even if the instances have not yet been added to their target pools. The change might take some time to apply to all of the instances in the group depending on the size of the group. """,
    tags=['compute_instance_groups_management', 'target_pool_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_set_target_pools(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManagersSetTargetPoolsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/updatePerInstanceConfigs',
    description=""" Inserts or updates per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_group_managers_update_per_instance_configs(
    project: str,
    zone: str = ...,
    instance_group_manager: str = Path(..., alias='instanceGroupManager'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupManagersUpdatePerInstanceConfigsReq = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instanceGroups',
    description=""" Retrieves the list of zonal instance group resources contained within the specified zone. For managed instance groups, use the instanceGroupManagers or regionInstanceGroupManagers methods instead. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_groups_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroups',
    description=""" Creates an instance group in the specified project using the parameters that are included in the request. """,
    tags=[
        'compute_instance_groups_management',
        'instance_management',
        'instance_configuration',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_groups_insert(
    project: str,
    zone: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}',
    description=""" Deletes the specified instance group. The instances in the group are not deleted. Note that instance group must not belong to a backend service. Read Deleting an instance group for more information. """,
    tags=['compute_instance_groups_management', 'compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_groups_delete(
    project: str,
    zone: str = ...,
    instance_group: str = Path(..., alias='instanceGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}',
    description=""" Returns the specified zonal instance group. Get a list of available zonal instance groups by making a list() request. For managed instance groups, use the instanceGroupManagers or regionInstanceGroupManagers methods instead. """,
    tags=['compute_instance_groups_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_groups_get(
    project: str,
    zone: str = ...,
    instance_group: str = Path(..., alias='instanceGroup'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}/addInstances',
    description=""" Adds a list of instances to the specified instance group. All of the instances in the instance group must be in the same network/subnetwork. Read Adding instances for more information. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_groups_add_instances(
    project: str,
    zone: str = ...,
    instance_group: str = Path(..., alias='instanceGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupsAddInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}/listInstances',
    description=""" Lists the instances in the specified instance group. The orderBy query parameter is not supported. The filter query parameter is supported, but only for expressions that use `eq` (equal) or `ne` (not equal) operators. """,
    tags=['compute_instance_groups_management', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_groups_list_instances(
    project: str,
    zone: str = ...,
    instance_group: str = Path(..., alias='instanceGroup'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupsListInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}/removeInstances',
    description=""" Removes one or more instances from the specified instance group, but does not delete those instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration before the VM instance is removed or deleted. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_groups_remove_instances(
    project: str,
    zone: str = ...,
    instance_group: str = Path(..., alias='instanceGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupsRemoveInstancesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}/setNamedPorts',
    description=""" Sets the named ports for the specified instance group. """,
    tags=['compute_instance_groups_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instance_groups_set_named_ports(
    project: str,
    zone: str = ...,
    instance_group: str = Path(..., alias='instanceGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstanceGroupsSetNamedPortsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instances',
    description=""" Retrieves the list of instances contained within the specified zone. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances',
    description=""" Creates an instance resource in the specified project using the data included in the request. """,
    tags=[
        'compute_instance_management',
        'compute_instance_template_management',
        'compute_image_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_insert(
    project: str,
    zone: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    source_instance_template: Optional[str] = Query(
        None, alias='sourceInstanceTemplate'
    ),
    source_machine_image: Optional[str] = Query(None, alias='sourceMachineImage'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Instance = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/bulkInsert',
    description=""" Creates multiple instances. Count specifies the number of instances to create. For more information, see About bulk creation of VMs. """,
    tags=[
        'project_management_operations',
        'compute_instance_management',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_bulk_insert(
    project: str,
    zone: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BulkInsertInstanceResource = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/zones/{zone}/instances/{instance}',
    description=""" Deletes the specified Instance resource. For more information, see Deleting an instance. """,
    tags=['project_management_operations', 'project_retrieval', 'zone_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_delete(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instances/{instance}',
    description=""" Returns the specified Instance resource. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'zone_management',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_get(
    project: str,
    zone: str = ...,
    instance: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{project}/zones/{zone}/instances/{instance}',
    description=""" Updates an instance only if the necessary resources are available. This method can update only a specific set of instance properties. See Updating a running instance for a list of updatable instance properties. """,
    tags=[
        'compute_instance_management',
        'instance_management',
        'project_management_operations',
        'instance_configuration',
        'instance_network_configuration',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_update(
    project: str,
    zone: str = ...,
    instance: str = ...,
    minimal_action: Optional[MinimalAction3] = Query(None, alias='minimalAction'),
    most_disruptive_allowed_action: Optional[MostDisruptiveAllowedAction3] = Query(
        None, alias='mostDisruptiveAllowedAction'
    ),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Instance = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/addAccessConfig',
    description=""" Adds an access config to an instance's network interface. """,
    tags=['compute_instance_management', 'network_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_add_access_config(
    project: str,
    zone: str = ...,
    instance: str = ...,
    network_interface: str = Query(..., alias='networkInterface'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: AccessConfig = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/addResourcePolicies',
    description=""" Adds existing resource policies to an instance. You can only add one policy right now which will be applied to this instance for scheduling live migrations. """,
    tags=[
        'compute_instance_management',
        'project_management_operations',
        'compute_instance_groups_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_add_resource_policies(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstancesAddResourcePoliciesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/attachDisk',
    description=""" Attaches an existing Disk resource to an instance. You must first create the disk before you can attach it. It is not possible to create and attach a disk at the same time. For more information, read Adding a persistent disk to your instance. """,
    tags=[
        'compute_instance_management',
        'instance_management',
        'instance_storage_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_attach_disk(
    project: str,
    zone: str = ...,
    instance: str = ...,
    force_attach: Optional[bool] = Query(None, alias='forceAttach'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: AttachedDisk = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/deleteAccessConfig',
    description=""" Deletes an access config from an instance's network interface. """,
    tags=[
        'instance_management',
        'instance_network_configuration',
        'compute_instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_delete_access_config(
    project: str,
    zone: str = ...,
    instance: str = ...,
    access_config: str = Query(..., alias='accessConfig'),
    network_interface: str = Query(..., alias='networkInterface'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/detachDisk',
    description=""" Detaches a disk from an instance. """,
    tags=[
        'project_management_operations',
        'compute_instance_management',
        'compute_network_operations',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_detach_disk(
    project: str,
    zone: str = ...,
    instance: str = ...,
    device_name: str = Query(..., alias='deviceName'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instances/{instance}/getEffectiveFirewalls',
    description=""" Returns effective firewalls applied to an interface of the instance. """,
    tags=['compute_instance_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_get_effective_firewalls(
    project: str,
    zone: str = ...,
    instance: str = ...,
    network_interface: str = Query(..., alias='networkInterface'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instances/{instance}/getGuestAttributes',
    description=""" Returns the specified guest attributes entry. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_get_guest_attributes(
    project: str,
    zone: str = ...,
    instance: str = ...,
    query_path: Optional[str] = Query(None, alias='queryPath'),
    variable_key: Optional[str] = Query(None, alias='variableKey'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instances/{instance}/getShieldedInstanceIdentity',
    description=""" Returns the Shielded Instance Identity of an instance """,
    tags=['project_management_operations', 'zone_management', 'instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_get_shielded_instance_identity(
    project: str,
    zone: str = ...,
    instance: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instances/{instance}/referrers',
    description=""" Retrieves a list of resources that refer to the VM instance specified in the request. For example, if the VM instance is part of a managed or unmanaged instance group, the referrers list includes the instance group. For more information, read Viewing referrers to VM instances. """,
    tags=[
        'compute_instance_management',
        'compute_instance_groups_management',
        'resource_aggregated_lists',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_list_referrers(
    project: str,
    zone: str = ...,
    instance: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/removeResourcePolicies',
    description=""" Removes resource policies from an instance. """,
    tags=[
        'compute_instance_management',
        'instance_management',
        'compute_instance_groups_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_remove_resource_policies(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstancesRemoveResourcePoliciesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/reset',
    description=""" Performs a reset on the instance. This is a hard reset. The VM does not do a graceful shutdown. For more information, see Resetting an instance. """,
    tags=['project_management_operations', 'zone_management', 'instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_reset(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/resume',
    description=""" Resumes an instance that was suspended using the instances().suspend method. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_resume(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instances/{instance}/screenshot',
    description=""" Returns the screenshot from the specified instance. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_get_screenshot(
    project: str,
    zone: str = ...,
    instance: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/sendDiagnosticInterrupt',
    description=""" Sends diagnostic interrupt to the instance. """,
    tags=['project_management_operations', 'zone_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_send_diagnostic_interrupt(
    project: str,
    zone: str = ...,
    instance: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instances/{instance}/serialPort',
    description=""" Returns the last 1 MB of serial port output from the specified instance. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_get_serial_port_output(
    project: str,
    zone: str = ...,
    instance: str = ...,
    port: Optional[conint(ge=1, le=4)] = None,
    start: Optional[str] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/setDiskAutoDelete',
    description=""" Sets the auto-delete flag for a disk attached to an instance. """,
    tags=[
        'instance_management',
        'instance_storage_management',
        'compute_instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_disk_auto_delete(
    project: str,
    zone: str = ...,
    instance: str = ...,
    auto_delete: bool = Query(..., alias='autoDelete'),
    device_name: str = Query(..., alias='deviceName'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/setLabels',
    description=""" Sets labels on an instance. To learn more about labels, read the Labeling Resources documentation. """,
    tags=['project_management_operations', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_labels(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstancesSetLabelsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/setMachineResources',
    description=""" Changes the number and/or type of accelerator for a stopped instance to the values specified in the request. """,
    tags=[
        'compute_instance_management',
        'compute_instance_configuration',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_machine_resources(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstancesSetMachineResourcesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/setMachineType',
    description=""" Changes the machine type for a stopped instance to the machine type specified in the request. """,
    tags=[
        'compute_instance_management',
        'machine_type_management',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_machine_type(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstancesSetMachineTypeRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/setMetadata',
    description=""" Sets metadata for the specified instance to the data included in the request. """,
    tags=[
        'project_management_operations',
        'compute_instance_management',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_metadata(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Metadata = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/setMinCpuPlatform',
    description=""" Changes the minimum CPU platform that this instance should use. This method can only be called on a stopped instance. For more information, read Specifying a Minimum CPU Platform. """,
    tags=['compute_instance_management', 'instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_min_cpu_platform(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstancesSetMinCpuPlatformRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/setName',
    description=""" Sets name of an instance. """,
    tags=[
        'compute_instance_management',
        'compute_instance_groups_management',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_name(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstancesSetNameRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/setScheduling',
    description=""" Sets an instance's scheduling options. You can only call this method on a stopped instance, that is, a VM instance that is in a `TERMINATED` state. See Instance Life Cycle for more information on the possible instance states. For more information about setting scheduling options for a VM, see Set VM host maintenance policy. """,
    tags=[
        'instance_management',
        'project_management_operations',
        'compute_instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_scheduling(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Scheduling = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/setServiceAccount',
    description=""" Sets the service account on the instance. For more information, read Changing the service account and access scopes for an instance. """,
    tags=[
        'compute_instance_management',
        'compute_instance_groups_management',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_service_account(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstancesSetServiceAccountRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/zones/{zone}/instances/{instance}/setShieldedInstanceIntegrityPolicy',
    description=""" Sets the Shielded Instance integrity policy for an instance. You can only use this method on a running instance. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=['compute_security_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_shielded_instance_integrity_policy(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ShieldedInstanceIntegrityPolicy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/setTags',
    description=""" Sets network tags for the specified instance to the data included in the request. """,
    tags=['project_management_operations', 'compute_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_tags(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Tags = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/simulateMaintenanceEvent',
    description=""" Simulates a host maintenance event on a VM. For more information, see Simulate a host maintenance event. """,
    tags=[
        'project_management_operations',
        'project_metadata_management',
        'instance_management',
        'zone_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_simulate_maintenance_event(
    project: str,
    zone: str = ...,
    instance: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/start',
    description=""" Starts an instance that was stopped using the instances().stop method. For more information, see Restart an instance. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_start(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey',
    description=""" Starts an instance that was stopped using the instances().stop method. For more information, see Restart an instance. """,
    tags=[
        'compute_instance_management',
        'instance_management',
        'instance_configuration',
        'instance_storage_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_start_with_encryption_key(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: InstancesStartWithEncryptionKeyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/stop',
    description=""" Stops a running instance, shutting it down cleanly, and allows you to restart the instance at a later time. Stopped instances do not incur VM usage charges while they are stopped. However, resources that the VM is using, such as persistent disks and static IP addresses, will continue to be charged until they are deleted. For more information, see Stopping an instance. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_stop(
    project: str,
    zone: str = ...,
    instance: str = ...,
    discard_local_ssd: Optional[bool] = Query(None, alias='discardLocalSsd'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/suspend',
    description=""" This method suspends a running instance, saving its state to persistent storage, and allows you to resume the instance at a later time. Suspended instances have no compute costs (cores or RAM), and incur only storage charges for the saved VM memory and localSSD data. Any charged resources the virtual machine was using, such as persistent disks and static IP addresses, will continue to be charged while the instance is suspended. For more information, see Suspending and resuming an instance. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_instance_management',
        'instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_suspend(
    project: str,
    zone: str = ...,
    instance: str = ...,
    discard_local_ssd: Optional[bool] = Query(None, alias='discardLocalSsd'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{instance}/updateAccessConfig',
    description=""" Updates the specified access config from an instance's network interface with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=[
        'instance_management',
        'instance_configuration',
        'compute_network_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_update_access_config(
    project: str,
    zone: str = ...,
    instance: str = ...,
    network_interface: str = Query(..., alias='networkInterface'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: AccessConfig = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/zones/{zone}/instances/{instance}/updateDisplayDevice',
    description=""" Updates the Display config for a VM instance. You can only use this method on a stopped VM instance. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=[
        'compute_instance_management',
        'instance_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_update_display_device(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: DisplayDevice = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/zones/{zone}/instances/{instance}/updateNetworkInterface',
    description=""" Updates an instance's network interface. This method can only update an interface's alias IP range and attached network. See Modifying alias IP ranges for an existing instance for instructions on changing alias IP ranges. See Migrating a VM between networks for instructions on migrating an interface. This method follows PATCH semantics. """,
    tags=['compute_network_operations', 'network_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_update_network_interface(
    project: str,
    zone: str = ...,
    instance: str = ...,
    network_interface: str = Query(..., alias='networkInterface'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworkInterface = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/zones/{zone}/instances/{instance}/updateShieldedInstanceConfig',
    description=""" Updates the Shielded Instance config for an instance. You can only use this method on a stopped instance. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. """,
    tags=[
        'project_management_operations',
        'compute_security_management',
        'compute_instance_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_update_shielded_instance_config(
    project: str,
    zone: str = ...,
    instance: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ShieldedInstanceConfig = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/instances/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_get_iam_policy(
    project: str,
    zone: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{resource}/setDeletionProtection',
    description=""" Sets deletion protection on the instance. """,
    tags=['project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_deletion_protection(
    project: str,
    zone: str = ...,
    resource: str = ...,
    deletion_protection: Optional[bool] = Query(None, alias='deletionProtection'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=[
        'zone_management',
        'project_management_operations',
        'resource_aggregated_lists',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_set_iam_policy(
    project: str,
    zone: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ZoneSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/instances/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=['project_management_operations', 'firewall_policy_iam_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_instances_test_iam_permissions(
    project: str,
    zone: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/machineTypes',
    description=""" Retrieves a list of machine types available to the specified project. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_machine_types_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/machineTypes/{machineType}',
    description=""" Returns the specified machine type. """,
    tags=['machine_type_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_machine_types_get(
    project: str,
    zone: str = ...,
    machine_type: str = Path(..., alias='machineType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/networkEndpointGroups',
    description=""" Retrieves the list of network endpoint groups that are located in the specified project and zone. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_endpoint_groups_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/networkEndpointGroups',
    description=""" Creates a network endpoint group in the specified project using the parameters that are included in the request. """,
    tags=['network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_endpoint_groups_insert(
    project: str,
    zone: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworkEndpointGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}',
    description=""" Deletes the specified network endpoint group. The network endpoints in the NEG and the VM instances they belong to are not terminated when the NEG is deleted. Note that the NEG cannot be deleted if there are backend services referencing it. """,
    tags=['network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_endpoint_groups_delete(
    project: str,
    zone: str = ...,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}',
    description=""" Returns the specified network endpoint group. """,
    tags=['network_management', 'network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_endpoint_groups_get(
    project: str,
    zone: str = ...,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}/attachNetworkEndpoints',
    description=""" Attach a list of network endpoints to the specified network endpoint group. """,
    tags=['network_endpoint_group_management', 'network_endpoint_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_endpoint_groups_attach_network_endpoints(
    project: str,
    zone: str = ...,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworkEndpointGroupsAttachEndpointsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}/detachNetworkEndpoints',
    description=""" Detach a list of network endpoints from the specified network endpoint group. """,
    tags=['network_endpoint_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_endpoint_groups_detach_network_endpoints(
    project: str,
    zone: str = ...,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworkEndpointGroupsDetachEndpointsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}/listNetworkEndpoints',
    description=""" Lists the network endpoints in the specified network endpoint group. """,
    tags=['network_endpoint_group_management', 'network_endpoint_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_endpoint_groups_list_network_endpoints(
    project: str,
    zone: str = ...,
    network_endpoint_group: str = Path(..., alias='networkEndpointGroup'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NetworkEndpointGroupsListEndpointsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/networkEndpointGroups/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_network_endpoint_groups_test_iam_permissions(
    project: str,
    zone: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/nodeGroups',
    description=""" Retrieves a list of node groups available to the specified project. Note: use nodeGroups.listNodes for more details about each group. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/nodeGroups',
    description=""" Creates a NodeGroup resource in the specified project using the data included in the request. """,
    tags=['node_group_management', 'node_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_insert(
    project: str,
    zone: str = ...,
    initial_node_count: int = Query(..., alias='initialNodeCount'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NodeGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}',
    description=""" Deletes the specified NodeGroup resource. """,
    tags=['node_group_management', 'node_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_delete(
    project: str,
    zone: str = ...,
    node_group: str = Path(..., alias='nodeGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}',
    description=""" Returns the specified NodeGroup. Get a list of available NodeGroups by making a list() request. Note: the "nodes" field should not be used. Use nodeGroups.listNodes instead. """,
    tags=['node_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_get(
    project: str,
    zone: str = ...,
    node_group: str = Path(..., alias='nodeGroup'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}',
    description=""" Updates the specified node group. """,
    tags=['node_group_management', 'node_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_patch(
    project: str,
    zone: str = ...,
    node_group: str = Path(..., alias='nodeGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NodeGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}/addNodes',
    description=""" Adds specified number of nodes to the node group. """,
    tags=['node_group_management', 'node_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_add_nodes(
    project: str,
    zone: str = ...,
    node_group: str = Path(..., alias='nodeGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NodeGroupsAddNodesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}/deleteNodes',
    description=""" Deletes specified nodes from the node group. """,
    tags=['node_group_management', 'node_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_delete_nodes(
    project: str,
    zone: str = ...,
    node_group: str = Path(..., alias='nodeGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NodeGroupsDeleteNodesRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}/listNodes',
    description=""" Lists nodes in the node group. """,
    tags=['node_group_management', 'node_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_list_nodes(
    project: str,
    zone: str = ...,
    node_group: str = Path(..., alias='nodeGroup'),
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}/setNodeTemplate',
    description=""" Updates the node template of the node group. """,
    tags=['node_group_management', 'node_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_set_node_template(
    project: str,
    zone: str = ...,
    node_group: str = Path(..., alias='nodeGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NodeGroupsSetNodeTemplateRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}/simulateMaintenanceEvent',
    description=""" Simulates maintenance event on specified nodes from the node group. """,
    tags=['node_management_operations', 'node_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_simulate_maintenance_event(
    project: str,
    zone: str = ...,
    node_group: str = Path(..., alias='nodeGroup'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: NodeGroupsSimulateMaintenanceEventRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/nodeGroups/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations', 'compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_get_iam_policy(
    project: str,
    zone: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/nodeGroups/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['zone_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_set_iam_policy(
    project: str,
    zone: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ZoneSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/nodeGroups/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=[
        'project_management_operations',
        'firewall_policy_iam_management',
        'firewall_policy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_groups_test_iam_permissions(
    project: str,
    zone: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/nodeTypes',
    description=""" Retrieves a list of node types available to the specified project. """,
    tags=['project_retrieval', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_types_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/nodeTypes/{nodeType}',
    description=""" Returns the specified node type. """,
    tags=['node_management_operations', 'node_type_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_node_types_get(
    project: str,
    zone: str = ...,
    node_type: str = Path(..., alias='nodeType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/operations',
    description=""" Retrieves a list of Operation resources contained within the specified zone. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_zone_operations_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/zones/{zone}/operations/{operation}',
    description=""" Deletes the specified zone-specific Operations resource. """,
    tags=['global_operations_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_zone_operations_delete(
    project: str,
    zone: str = ...,
    operation: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/operations/{operation}',
    description=""" Retrieves the specified zone-specific Operations resource. """,
    tags=[
        'global_operations_management',
        'project_management_operations',
        'project_retrieval',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_zone_operations_get(
    project: str,
    zone: str = ...,
    operation: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/operations/{operation}/wait',
    description=""" Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method waits for no more than the 2 minutes and then returns the current state of the operation, which might be `DONE` or still in progress. This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.  """,
    tags=['global_operations_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_zone_operations_wait(
    project: str,
    zone: str = ...,
    operation: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/reservations',
    description=""" A list of all the reservations that have been configured for the specified project in specified zone. """,
    tags=['project_management_operations', 'global_operations_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_reservations_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/reservations',
    description=""" Creates a new reservation. For more information, read Reserving zonal resources. """,
    tags=['reservation_management', 'compute_resource_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_reservations_insert(
    project: str,
    zone: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Reservation = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/zones/{zone}/reservations/{reservation}',
    description=""" Deletes the specified reservation. """,
    tags=[
        'reservation_management',
        'reservation_iam_management',
        'project_management_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_reservations_delete(
    project: str,
    zone: str = ...,
    reservation: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/reservations/{reservation}',
    description=""" Retrieves information about the specified reservation. """,
    tags=[
        'reservation_management',
        'reservation_iam_management',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_reservations_get(
    project: str,
    zone: str = ...,
    reservation: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{project}/zones/{zone}/reservations/{reservation}',
    description=""" Update share settings of the reservation. """,
    tags=[
        'reservation_management',
        'reservation_iam_management',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_reservations_update(
    project: str,
    zone: str = ...,
    reservation: str = ...,
    paths: Optional[Paths] = None,
    request_id: Optional[str] = Query(None, alias='requestId'),
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Reservation = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/reservations/{reservation}/resize',
    description=""" Resizes the reservation (applicable to standalone reservations only). For more information, read Modifying reservations. """,
    tags=[
        'reservation_management',
        'reservation_iam_management',
        'compute_resource_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_reservations_resize(
    project: str,
    zone: str = ...,
    reservation: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ReservationsResizeRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/reservations/{resource}/getIamPolicy',
    description=""" Gets the access control policy for a resource. May be empty if no such policy or resource exists. """,
    tags=['project_management_operations', 'project_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_reservations_get_iam_policy(
    project: str,
    zone: str = ...,
    resource: str = ...,
    options_requested_policy_version: Optional[int] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/reservations/{resource}/setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. """,
    tags=['project_management_operations', 'zone_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_reservations_set_iam_policy(
    project: str,
    zone: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ZoneSetPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/reservations/{resource}/testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. """,
    tags=[
        'project_management_operations',
        'project_retrieval',
        'firewall_policy_iam_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_reservations_test_iam_permissions(
    project: str,
    zone: str = ...,
    resource: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/targetInstances',
    description=""" Retrieves a list of TargetInstance resources available to the specified project and zone. """,
    tags=['project_management_operations', 'project_retrieval', 'zone_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_instances_list(
    project: str,
    zone: str = ...,
    filter: Optional[str] = None,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    return_partial_success: Optional[bool] = Query(None, alias='returnPartialSuccess'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{project}/zones/{zone}/targetInstances',
    description=""" Creates a TargetInstance resource in the specified project and zone using the data included in the request. """,
    tags=['target_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_instances_insert(
    project: str,
    zone: str = ...,
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TargetInstance = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{project}/zones/{zone}/targetInstances/{targetInstance}',
    description=""" Deletes the specified TargetInstance resource. """,
    tags=['target_instance_management', 'project_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_instances_delete(
    project: str,
    zone: str = ...,
    target_instance: str = Path(..., alias='targetInstance'),
    request_id: Optional[str] = Query(None, alias='requestId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{project}/zones/{zone}/targetInstances/{targetInstance}',
    description=""" Returns the specified TargetInstance resource. """,
    tags=['target_instance_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def compute_target_instances_get(
    project: str,
    zone: str = ...,
    target_instance: str = Path(..., alias='targetInstance'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
